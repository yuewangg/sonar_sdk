/*
    This file has been generated by bvtidl.pl. DO NOT MODIFY!
*/

#ifndef __CPP_BVTNAVDATA_HPP__
#define __CPP_BVTNAVDATA_HPP__

#include <string>
#ifdef _WIN32
#   include <memory>
#else
#   include <cstddef>
#   if defined (__GLIBCXX__) && __cplusplus <= 199711L
#      include <tr1/memory>
       namespace std {
          using std::tr1::shared_ptr;
       }
#   else
#       include <memory>
#   endif
#endif
#include <bvt_cpp/bvt_retval.hpp>
#include <bvt_cpp/bvt_error.hpp>

namespace BVTSDK
{

    /// <summary>
    /// NavData contains various types of user-accessible navigation parameter, which
    /// can be saved to and retrieved from a sonar file on a per ping basis.
    /// The NavData objects can be created and destroyed as needed. When the
    /// ping functions are called to get or put the data, the data is copied.
    /// This allows NavData objects to be pre-allocated and filled from various
    /// instrument sources. It also allows the data to be copied from one
    /// NavData object to the other.
    /// NOTE: NavData changes will only be saved to a sonar of type FILE. 
    /// <summary>
    class NavData
    {
    public:
        NavData()
        {
            BVTNavData p = BVTNavData_Create();
            _owned = std::shared_ptr<BVTOpaqueNavData>(p , BVTNavData_Destroy );
        }
    public: /*consider private*/
        NavData(BVTNavData p)
        {
            _owned = std::shared_ptr<BVTOpaqueNavData>(p , BVTNavData_Destroy );
        }
    public:
        ~NavData()
        {
            
        }

    //public:
    //  NavData(const NavData &) {}
    //  NavData& operator=(const NavData &) {}
    public:
        /// SDK object pointer
        BVTNavData Handle() const
        {
            return _owned.get();
        }
    private:
        std::shared_ptr<BVTOpaqueNavData> _owned;

    public:
        //
        // Clones the data from the passed NavData object to this object. Both objects
        // must have already been created.
        //
        // @param navdata_to_clone existing NavData object to copy from         
        void Clone(const NavData & navdata_to_clone)
        {
            int error_code = BVTNavData_Clone(_owned.get(), navdata_to_clone.Handle());
            if (0 != error_code)
                throw SdkException(error_code);
        }

        //
        // Clones the data from the passed NavData object to this object. Both objects
        // must have already been created.
        //
        // @param navdata_to_clone existing NavData object to copy from         
        void CloneFrom(const NavData & navdata_to_clone)
        {
            int error_code = BVTNavData_CloneFrom(_owned.get(), navdata_to_clone.Handle());
            if (0 != error_code)
                throw SdkException(error_code);
        }

        //
        // Clears all fields in the NavData object so that the object may
        // be reused. Following a call to this method, IsEmpty() returns
        // true.
        //      
        void Clear()
        {
            int error_code = BVTNavData_Clear(_owned.get());
            if (0 != error_code)
                throw SdkException(error_code);
        }

        //
        // Returns true(1) if the NavData object contains no valid data.
        //
        // @param empty true if this NavData object is empty        
        bool IsEmpty()
        {
            int empty;
            int error_code = BVTNavData_IsEmpty(_owned.get(), /* out */ &empty);
            if (0 != error_code)
                throw SdkException(error_code);
            return empty > 0;
        }

        //
        // Combines the fields of two NavData objects according to the following rules:
        // 1) If a field is populated in one object and empty in the other, the value from the populated object is kept
        // 2) If a field is full in both objects, the value with the more
        // recent timestamp is kept
        // 3) If a field is empty in both objects, it remains empty
        //
        // @param other The source NavData to merge into this NavData       
        void Merge(const NavData & other)
        {
            int error_code = BVTNavData_Merge(_owned.get(), other.Handle());
            if (0 != error_code)
                throw SdkException(error_code);
        }

        //
        // Clears all fields whose time of receipt is older than the value specified by timestamp (as provided by the system clock). Returns the number of valid fields left.
        //
        // @param timestamp The absolute timestamp, in seconds, for data to be considered stale
        // @param remainingFieldCount the number of remaining valid fields after pruning stale fields       
        int ClearStaleFields(double timestamp)
        {
            int remainingFieldCount;
            int error_code = BVTNavData_ClearStaleFields(_owned.get(), timestamp, /* out */ &remainingFieldCount);
            if (0 != error_code)
                throw SdkException(error_code);
            return remainingFieldCount;
        }

        //
        // A single NavData object may contain data that was acquired over some length of time. This
        // function allows the user to determine what that length is.
        //
        // @param start The Unix timestamp representing the earliest data contained in the object 
        // @param stop The Unix timestamp representing the latest data contained in the object      
        void GetTimespan(double *start, double *stop)
        {
            int error_code = BVTNavData_GetTimespan(_owned.get(), start, stop);
            if (0 != error_code)
                throw SdkException(error_code);
        }

        //
        // Returns the latitude. If no latitude was stored, returns BVT_NAV_NO_DATA.
        //
        // @param degrees latitude in degrees       
        double GetLatitude()
        {
            double degrees;
            int error_code = BVTNavData_GetLatitude(_owned.get(), /* out */ &degrees);
            if (0 != error_code)
                throw SdkException(error_code);
            return degrees;
        }

        //
        // Returns the latitude. If no latitude was stored, returns BVT_NAV_NO_DATA.
        //
        // @param degrees latitude in degrees       
        bool TryGetLatitude(double *degrees)
        {
            int error_code = BVTNavData_GetLatitude(_owned.get(), degrees);
            if (0 != error_code)
            return true;
            {
                *degrees = 0.0;
                return false;
            }
        }

        //
        // Returns the Unix epoch time at which the field was set, including fractional seconds. 
        // If no data was stored, the returns zero.
        // NOTE: Timestamps are generated based on the value of the system clock at the time the
        // field was set. As such, they are subject to substantial error due to clock drift and
        // system latency and are in no way synchronized to any global standard. If such synchronization
        // is required, please use the NavTime field and consider using a PPS signal.
        //
        // @param timestamp timestamp in seconds        
        double GetLatitudeTimestamp()
        {
            double timestamp;
            int error_code = BVTNavData_GetLatitudeTimestamp(_owned.get(), /* out */ &timestamp);
            if (0 != error_code)
                throw SdkException(error_code);
            return timestamp;
        }

        //
        // Stores the latitude, as a signed floating point number of degrees.
        // Latitudes in the Southern hemisphere are expressed as negative numbers.
        //
        // @param degrees latitude in degrees       
        void SetLatitude(double degrees)
        {
            int error_code = BVTNavData_SetLatitude(_owned.get(), degrees);
            if (0 != error_code)
                throw SdkException(error_code);
        }

        //
        // Returns the longitude. If no longitude was stored, returns BVT_NAV_NO_DATA.
        //
        // @param degrees longitude in degrees      
        double GetLongitude()
        {
            double degrees;
            int error_code = BVTNavData_GetLongitude(_owned.get(), /* out */ &degrees);
            if (0 != error_code)
                throw SdkException(error_code);
            return degrees;
        }

        //
        // Returns the longitude. If no longitude was stored, returns BVT_NAV_NO_DATA.
        //
        // @param degrees longitude in degrees      
        bool TryGetLongitude(double *degrees)
        {
            int error_code = BVTNavData_GetLongitude(_owned.get(), degrees);
            if (0 != error_code)
            return true;
            {
                *degrees = 0.0;
                return false;
            }
        }

        //
        // Returns the Unix epoch time at which the field was set, including fractional seconds. 
        // If no data was stored, the returns zero.
        // NOTE: Timestamps are generated based on the value of the system clock at the time the
        // field was set. As such, they are subject to substantial error due to clock drift and
        // system latency and are in no way synchronized to any global standard. If such synchronization
        // is required, please use the NavTime field and consider using a PPS signal.
        //
        // @param timestamp timestamp       
        double GetLongitudeTimestamp()
        {
            double timestamp;
            int error_code = BVTNavData_GetLongitudeTimestamp(_owned.get(), /* out */ &timestamp);
            if (0 != error_code)
                throw SdkException(error_code);
            return timestamp;
        }

        //
        // Stores the longitude, as a signed floating point number of degrees.
        // Longitudes in the Western hemisphere are expressed as negative numbers.
        //
        // @param degrees longitude in degrees      
        void SetLongitude(double degrees)
        {
            int error_code = BVTNavData_SetLongitude(_owned.get(), degrees);
            if (0 != error_code)
                throw SdkException(error_code);
        }

        //
        // Returns the estimated horizontal error (see next function for details). 
        // If none was stored, returns BVT_NAV_NO_DATA.
        //
        // @param error_meters potential error distance, in meters      
        float GetHorizontalPrecisionError()
        {
            float error_meters;
            int error_code = BVTNavData_GetHorizontalPrecisionError(_owned.get(), /* out */ &error_meters);
            if (0 != error_code)
                throw SdkException(error_code);
            return error_meters;
        }

        //
        // Returns the estimated horizontal error (see next function for details). 
        // If none was stored, returns BVT_NAV_NO_DATA.
        //
        // @param error_meters potential error distance, in meters      
        bool TryGetHorizontalPrecisionError(float *error_meters)
        {
            int error_code = BVTNavData_GetHorizontalPrecisionError(_owned.get(), error_meters);
            if (0 != error_code)
            return true;
            {
                *error_meters = 0.0f;
                return false;
            }
        }

        //
        // )
        // Returns the Unix epoch time at which the field was set, including fractional seconds. 
        // If no data was stored, the returns zero.
        // NOTE: Timestamps are generated based on the value of the system clock at the time the
        // field was set. As such, they are subject to substantial error due to clock drift and
        // system latency and are in no way synchronized to any global standard. If such synchronization
        // is required, please use the NavTime field and consider using a PPS signal.
        //
        // @param timestamp timestamp       
        double GetHorizontalPrecisionErrorTimestamp()
        {
            double timestamp;
            int error_code = BVTNavData_GetHorizontalPrecisionErrorTimestamp(_owned.get(), /* out */ &timestamp);
            if (0 != error_code)
                throw SdkException(error_code);
            return timestamp;
        }

        //
        // Stores the estimated possible horizontal error. This is primarily (but not exclusively)
        // intended for GPS systems, where there may be some doubt as to the
        // quality of the position fix. HDOP is common, but not used here, as
        // that is a unitless measure and varies between different manufacturers and models. <br>
        // The idea is to use whatever calculations are appropriate for the 
        // local navigation system, and store a possible error value in meters.
        // Some GPS units will attempt to give this directly. (for example,
        // the HPE field in the PGRME sentence, supplied by some Garmin units.)
        // In the case of large errors, or old data, it may be best to either
        // not store a position, or not store new data. (also consider using
        // the NavData time parameter to store the time of last fix, which
        // can then be compared to the ping time when the data is read back to
        // determine the age of the GPS reading.)
        //
        // @param error_meters potential error distance, in meters      
        void SetHorizontalPrecisionError(float error_meters)
        {
            int error_code = BVTNavData_SetHorizontalPrecisionError(_owned.get(), error_meters);
            if (0 != error_code)
                throw SdkException(error_code);
        }

        //
        // Returns the height above Mean Sea Level. If no value was stored for
        // this ping, returns BVT_NAV_NO_DATA.
        //
        // @param meters_above_geoid height in meters       
        float GetHeight()
        {
            float meters_above_geoid;
            int error_code = BVTNavData_GetHeight(_owned.get(), /* out */ &meters_above_geoid);
            if (0 != error_code)
                throw SdkException(error_code);
            return meters_above_geoid;
        }

        //
        // Returns the height above Mean Sea Level. If no value was stored for
        // this ping, returns BVT_NAV_NO_DATA.
        //
        // @param meters_above_geoid height in meters       
        bool TryGetHeight(float *meters_above_geoid)
        {
            int error_code = BVTNavData_GetHeight(_owned.get(), meters_above_geoid);
            if (0 != error_code)
            return true;
            {
                *meters_above_geoid = 0.0f;
                return false;
            }
        }

        //
        // Returns the Unix epoch time at which the field was set, including fractional seconds. 
        // If no data was stored, the returns zero.
        // NOTE: Timestamps are generated based on the value of the system clock at the time the
        // field was set. As such, they are subject to substantial error due to clock drift and
        // system latency and are in no way synchronized to any global standard. If such synchronization
        // is required, please use the NavTime field and consider using a PPS signal.
        //
        // @param timestamp timestamp       
        double GetHeightTimestamp()
        {
            double timestamp;
            int error_code = BVTNavData_GetHeightTimestamp(_owned.get(), /* out */ &timestamp);
            if (0 != error_code)
                throw SdkException(error_code);
            return timestamp;
        }

        //
        // Store the height above Mean Sea Level (usually the EGM96 geoid)
        //
        // @param meters_above_geoid height in meters       
        void SetHeight(float meters_above_geoid)
        {
            int error_code = BVTNavData_SetHeight(_owned.get(), meters_above_geoid);
            if (0 != error_code)
                throw SdkException(error_code);
        }

        //
        // Returns the estimated vertical error (see next function for details). 
        // If none was stored, returns BVT_NAV_NO_DATA.
        //
        // @param error_meters potential error distance, in meters      
        float GetVerticalPrecisionError()
        {
            float error_meters;
            int error_code = BVTNavData_GetVerticalPrecisionError(_owned.get(), /* out */ &error_meters);
            if (0 != error_code)
                throw SdkException(error_code);
            return error_meters;
        }

        //
        // Returns the estimated vertical error (see next function for details). 
        // If none was stored, returns BVT_NAV_NO_DATA.
        //
        // @param error_meters potential error distance, in meters      
        bool TryGetVerticalPrecisionError(float *error_meters)
        {
            int error_code = BVTNavData_GetVerticalPrecisionError(_owned.get(), error_meters);
            if (0 != error_code)
            return true;
            {
                *error_meters = 0.0f;
                return false;
            }
        }

        //
        // Returns the Unix epoch time at which the field was set, including fractional seconds. 
        // If no data was stored, the returns zero.
        // NOTE: Timestamps are generated based on the value of the system clock at the time the
        // field was set. As such, they are subject to substantial error due to clock drift and
        // system latency and are in no way synchronized to any global standard. If such synchronization
        // is required, please use the NavTime field and consider using a PPS signal.
        //
        // @param timestamp timestamp       
        double GetVerticalPrecisionErrorTimestamp()
        {
            double timestamp;
            int error_code = BVTNavData_GetVerticalPrecisionErrorTimestamp(_owned.get(), /* out */ &timestamp);
            if (0 != error_code)
                throw SdkException(error_code);
            return timestamp;
        }

        //
        // Stores the estimated possible vertical error (height) above 
        // Mean Sea Level (EGM96 geoid).  For other notes, see the functions
        // or Horizontal Precision Error, above.
        //
        // @param error_meters potential error distance, in meters      
        void SetVerticalPrecisionError(float error_meters)
        {
            int error_code = BVTNavData_SetVerticalPrecisionError(_owned.get(), error_meters);
            if (0 != error_code)
                throw SdkException(error_code);
        }

        //
        // Returns the depth. If no value was stored for this ping, returns
        // BVT_NAV_NO_DATA.
        //
        // @param meters_below_surface depth in floating point meters       
        float GetDepth()
        {
            float meters_below_surface;
            int error_code = BVTNavData_GetDepth(_owned.get(), /* out */ &meters_below_surface);
            if (0 != error_code)
                throw SdkException(error_code);
            return meters_below_surface;
        }

        //
        // Returns the depth. If no value was stored for this ping, returns
        // BVT_NAV_NO_DATA.
        //
        // @param meters_below_surface depth in floating point meters       
        bool TryGetDepth(float *meters_below_surface)
        {
            int error_code = BVTNavData_GetDepth(_owned.get(), meters_below_surface);
            if (0 != error_code)
            return true;
            {
                *meters_below_surface = 0.0f;
                return false;
            }
        }

        //
        // Returns the Unix epoch time at which the field was set, including fractional seconds. 
        // If no data was stored, the returns zero.
        // NOTE: Timestamps are generated based on the value of the system clock at the time the
        // field was set. As such, they are subject to substantial error due to clock drift and
        // system latency and are in no way synchronized to any global standard. If such synchronization
        // is required, please use the NavTime field and consider using a PPS signal.
        //
        // @param timestamp timestamp in seconds        
        double GetDepthTimestamp()
        {
            double timestamp;
            int error_code = BVTNavData_GetDepthTimestamp(_owned.get(), /* out */ &timestamp);
            if (0 != error_code)
                throw SdkException(error_code);
            return timestamp;
        }

        //
        // Store the depth.
        //
        // @param meters_below_surface depth in floating point meters       
        void SetDepth(float meters_below_surface)
        {
            int error_code = BVTNavData_SetDepth(_owned.get(), meters_below_surface);
            if (0 != error_code)
                throw SdkException(error_code);
        }

        //
        // Returns the altitude. If no value was stored for this ping, returns
        // BVT_NAV_NO_DATA.
        //
        // @param meters_above_bottom altitude in floating point meters         
        float GetAltitude()
        {
            float meters_above_bottom;
            int error_code = BVTNavData_GetAltitude(_owned.get(), /* out */ &meters_above_bottom);
            if (0 != error_code)
                throw SdkException(error_code);
            return meters_above_bottom;
        }

        //
        // Returns the altitude. If no value was stored for this ping, returns
        // BVT_NAV_NO_DATA.
        //
        // @param meters_above_bottom altitude in floating point meters         
        bool TryGetAltitude(float *meters_above_bottom)
        {
            int error_code = BVTNavData_GetAltitude(_owned.get(), meters_above_bottom);
            if (0 != error_code)
            return true;
            {
                *meters_above_bottom = 0.0f;
                return false;
            }
        }

        //
        // Returns the Unix epoch time at which the field was set, including fractional seconds. 
        // If no data was stored, the returns zero.
        // NOTE: Timestamps are generated based on the value of the system clock at the time the
        // field was set. As such, they are subject to substantial error due to clock drift and
        // system latency and are in no way synchronized to any global standard. If such synchronization
        // is required, please use the NavTime field and consider using a PPS signal.
        //
        // @param timestamp timestamp in seconds        
        double GetAltitudeTimestamp()
        {
            double timestamp;
            int error_code = BVTNavData_GetAltitudeTimestamp(_owned.get(), /* out */ &timestamp);
            if (0 != error_code)
                throw SdkException(error_code);
            return timestamp;
        }

        //
        // Store the altitude.
        //
        // @param meters_above_bottom altitude in floating point meters         
        void SetAltitude(float meters_above_bottom)
        {
            int error_code = BVTNavData_SetAltitude(_owned.get(), meters_above_bottom);
            if (0 != error_code)
                throw SdkException(error_code);
        }

        //
        // Returns the heading relative to True North. If no value was stored
        // for this ping, returns BVT_NAV_NO_DATA.
        //
        // @param degrees_true True heading, in degrees         
        float GetHeading()
        {
            float degrees_true;
            int error_code = BVTNavData_GetHeading(_owned.get(), /* out */ &degrees_true);
            if (0 != error_code)
                throw SdkException(error_code);
            return degrees_true;
        }

        //
        // Returns the heading relative to True North. If no value was stored
        // for this ping, returns BVT_NAV_NO_DATA.
        //
        // @param degrees_true True heading, in degrees         
        bool TryGetHeading(float *degrees_true)
        {
            int error_code = BVTNavData_GetHeading(_owned.get(), degrees_true);
            if (0 != error_code)
            return true;
            {
                *degrees_true = 0.0f;
                return false;
            }
        }

        //
        // Returns the Unix epoch time at which the field was set, including fractional seconds. 
        // If no data was stored, the returns zero.
        // NOTE: Timestamps are generated based on the value of the system clock at the time the
        // field was set. As such, they are subject to substantial error due to clock drift and
        // system latency and are in no way synchronized to any global standard. If such synchronization
        // is required, please use the NavTime field and consider using a PPS signal.
        //
        // @param timestamp timestamp in seconds        
        double GetHeadingTimestamp()
        {
            double timestamp;
            int error_code = BVTNavData_GetHeadingTimestamp(_owned.get(), /* out */ &timestamp);
            if (0 != error_code)
                throw SdkException(error_code);
            return timestamp;
        }

        //
        // Store the heading relative to True North.
        //
        // @param degrees_true True heading, in degrees         
        void SetHeading(float degrees_true)
        {
            int error_code = BVTNavData_SetHeading(_owned.get(), degrees_true);
            if (0 != error_code)
                throw SdkException(error_code);
        }

        //
        // Returns the velocity along the heading. If no value was stored
        // for this ping, returns BVT_NAV_NO_DATA.
        //
        // @param meters_per_second velocity, in meters per second      
        float GetHeadingVelocity()
        {
            float meters_per_second;
            int error_code = BVTNavData_GetHeadingVelocity(_owned.get(), /* out */ &meters_per_second);
            if (0 != error_code)
                throw SdkException(error_code);
            return meters_per_second;
        }

        //
        // Returns the velocity along the heading. If no value was stored
        // for this ping, returns BVT_NAV_NO_DATA.
        //
        // @param meters_per_second velocity, in meters per second      
        bool TryGetHeadingVelocity(float *meters_per_second)
        {
            int error_code = BVTNavData_GetHeadingVelocity(_owned.get(), meters_per_second);
            if (0 != error_code)
            return true;
            {
                *meters_per_second = 0.0f;
                return false;
            }
        }

        //
        // Returns the Unix epoch time at which the field was set, including fractional seconds. 
        // If no data was stored, the returns zero.
        // NOTE: Timestamps are generated based on the value of the system clock at the time the
        // field was set. As such, they are subject to substantial error due to clock drift and
        // system latency and are in no way synchronized to any global standard. If such synchronization
        // is required, please use the NavTime field and consider using a PPS signal.
        //
        // @param timestamp timestamp in seconds        
        double GetHeadingVelocityTimestamp()
        {
            double timestamp;
            int error_code = BVTNavData_GetHeadingVelocityTimestamp(_owned.get(), /* out */ &timestamp);
            if (0 != error_code)
                throw SdkException(error_code);
            return timestamp;
        }

        //
        // Store the velocity along the heading.
        //
        // @param meters_per_second velocity, in meters per second      
        void SetHeadingVelocity(float meters_per_second)
        {
            int error_code = BVTNavData_SetHeadingVelocity(_owned.get(), meters_per_second);
            if (0 != error_code)
                throw SdkException(error_code);
        }

        //
        // Returns the course over ground (true). If no value was stored for
        // this ping, returns BVT_NAV_NO_DATA.
        //
        // @param degrees_true course over ground, true, in degrees         
        float GetCourseOverGround()
        {
            float degrees_true;
            int error_code = BVTNavData_GetCourseOverGround(_owned.get(), /* out */ &degrees_true);
            if (0 != error_code)
                throw SdkException(error_code);
            return degrees_true;
        }

        //
        // Returns the course over ground (true). If no value was stored for
        // this ping, returns BVT_NAV_NO_DATA.
        //
        // @param degrees_true course over ground, true, in degrees         
        bool TryGetCourseOverGround(float *degrees_true)
        {
            int error_code = BVTNavData_GetCourseOverGround(_owned.get(), degrees_true);
            if (0 != error_code)
            return true;
            {
                *degrees_true = 0.0f;
                return false;
            }
        }

        //
        // Returns the Unix epoch time at which the field was set, including fractional seconds. 
        // If no data was stored, the returns zero.
        // NOTE: Timestamps are generated based on the value of the system clock at the time the
        // field was set. As such, they are subject to substantial error due to clock drift and
        // system latency and are in no way synchronized to any global standard. If such synchronization
        // is required, please use the NavTime field and consider using a PPS signal.
        //
        // @param timestamp timestamp in seconds        
        double GetCourseOverGroundTimestamp()
        {
            double timestamp;
            int error_code = BVTNavData_GetCourseOverGroundTimestamp(_owned.get(), /* out */ &timestamp);
            if (0 != error_code)
                throw SdkException(error_code);
            return timestamp;
        }

        //
        // Store the course over ground, true.
        //
        // @param degrees_true course over ground, true, in degrees         
        void SetCourseOverGround(float degrees_true)
        {
            int error_code = BVTNavData_SetCourseOverGround(_owned.get(), degrees_true);
            if (0 != error_code)
                throw SdkException(error_code);
        }

        //
        // Returns the speed over ground. If no value was stored for this ping,
        // returns BVT_NAV_NO_DATA.
        //
        // @param meters_per_second speed over ground, in meters per second         
        float GetSpeedOverGround()
        {
            float meters_per_second;
            int error_code = BVTNavData_GetSpeedOverGround(_owned.get(), /* out */ &meters_per_second);
            if (0 != error_code)
                throw SdkException(error_code);
            return meters_per_second;
        }

        //
        // Returns the speed over ground. If no value was stored for this ping,
        // returns BVT_NAV_NO_DATA.
        //
        // @param meters_per_second speed over ground, in meters per second         
        bool TryGetSpeedOverGround(float *meters_per_second)
        {
            int error_code = BVTNavData_GetSpeedOverGround(_owned.get(), meters_per_second);
            if (0 != error_code)
            return true;
            {
                *meters_per_second = 0.0f;
                return false;
            }
        }

        //
        // Returns the Unix epoch time at which the field was set, including fractional seconds. 
        // If no data was stored, the returns zero.
        // NOTE: Timestamps are generated based on the value of the system clock at the time the
        // field was set. As such, they are subject to substantial error due to clock drift and
        // system latency and are in no way synchronized to any global standard. If such synchronization
        // is required, please use the NavTime field and consider using a PPS signal.
        //
        // @param timestamp timestamp in seconds        
        double GetSpeedOverGroundTimestamp()
        {
            double timestamp;
            int error_code = BVTNavData_GetSpeedOverGroundTimestamp(_owned.get(), /* out */ &timestamp);
            if (0 != error_code)
                throw SdkException(error_code);
            return timestamp;
        }

        //
        // Store the speed over ground.
        //
        // @param meters_per_second speed over ground, in meters per second         
        void SetSpeedOverGround(float meters_per_second)
        {
            int error_code = BVTNavData_SetSpeedOverGround(_owned.get(), meters_per_second);
            if (0 != error_code)
                throw SdkException(error_code);
        }

        //
        // Get the pitch angle. If no value was stored for this ping, returns BVT_NAV_NO_DATA.
        //
        // @param degrees_bow_up pitch angle, in floating point degrees, bow up is positive         
        float GetPitchAngle()
        {
            float degrees_bow_up;
            int error_code = BVTNavData_GetPitchAngle(_owned.get(), /* out */ &degrees_bow_up);
            if (0 != error_code)
                throw SdkException(error_code);
            return degrees_bow_up;
        }

        //
        // Get the pitch angle. If no value was stored for this ping, returns BVT_NAV_NO_DATA.
        //
        // @param degrees_bow_up pitch angle, in floating point degrees, bow up is positive         
        bool TryGetPitchAngle(float *degrees_bow_up)
        {
            int error_code = BVTNavData_GetPitchAngle(_owned.get(), degrees_bow_up);
            if (0 != error_code)
            return true;
            {
                *degrees_bow_up = 0.0f;
                return false;
            }
        }

        //
        // Returns the Unix epoch time at which the field was set, including fractional seconds. 
        // If no data was stored, the returns zero.
        // NOTE: Timestamps are generated based on the value of the system clock at the time the
        // field was set. As such, they are subject to substantial error due to clock drift and
        // system latency and are in no way synchronized to any global standard. If such synchronization
        // is required, please use the NavTime field and consider using a PPS signal.
        //
        // @param timestamp timestamp in seconds        
        double GetPitchAngleTimestamp()
        {
            double timestamp;
            int error_code = BVTNavData_GetPitchAngleTimestamp(_owned.get(), /* out */ &timestamp);
            if (0 != error_code)
                throw SdkException(error_code);
            return timestamp;
        }

        //
        // Store the pitch angle.
        //
        // @param degrees_bow_up pitch angle, in floating point degrees, bow up is positive         
        void SetPitchAngle(float degrees_bow_up)
        {
            int error_code = BVTNavData_SetPitchAngle(_owned.get(), degrees_bow_up);
            if (0 != error_code)
                throw SdkException(error_code);
        }

        //
        // Get the roll angle. If no value was stored for this ping, returns BVT_NAV_NO_DATA.
        //
        // @param degrees_port_up roll angle, in floating point degrees, port side up is positive       
        float GetRollAngle()
        {
            float degrees_port_up;
            int error_code = BVTNavData_GetRollAngle(_owned.get(), /* out */ &degrees_port_up);
            if (0 != error_code)
                throw SdkException(error_code);
            return degrees_port_up;
        }

        //
        // Get the roll angle. If no value was stored for this ping, returns BVT_NAV_NO_DATA.
        //
        // @param degrees_port_up roll angle, in floating point degrees, port side up is positive       
        bool TryGetRollAngle(float *degrees_port_up)
        {
            int error_code = BVTNavData_GetRollAngle(_owned.get(), degrees_port_up);
            if (0 != error_code)
            return true;
            {
                *degrees_port_up = 0.0f;
                return false;
            }
        }

        //
        // Returns the Unix epoch time at which the field was set, including fractional seconds. 
        // If no data was stored, the returns zero.
        // NOTE: Timestamps are generated based on the value of the system clock at the time the
        // field was set. As such, they are subject to substantial error due to clock drift and
        // system latency and are in no way synchronized to any global standard. If such synchronization
        // is required, please use the NavTime field and consider using a PPS signal.
        //
        // @param timestamp timestamp in seconds        
        double GetRollAngleTimestamp()
        {
            double timestamp;
            int error_code = BVTNavData_GetRollAngleTimestamp(_owned.get(), /* out */ &timestamp);
            if (0 != error_code)
                throw SdkException(error_code);
            return timestamp;
        }

        //
        // Store the roll angle.
        //
        // @param degrees_port_up roll angle, in floating point degrees, port side up is positive       
        void SetRollAngle(float degrees_port_up)
        {
            int error_code = BVTNavData_SetRollAngle(_owned.get(), degrees_port_up);
            if (0 != error_code)
                throw SdkException(error_code);
        }

        //
        // Get the roll angle (but see notes with SetYawAngle() ). If no value was stored for this ping, returns BVT_NAV_NO_DATA.
        //
        // @param degrees_bow_to_starboard yaw angle, in floating point degrees         
        float GetYawAngle()
        {
            float degrees_bow_to_starboard;
            int error_code = BVTNavData_GetYawAngle(_owned.get(), /* out */ &degrees_bow_to_starboard);
            if (0 != error_code)
                throw SdkException(error_code);
            return degrees_bow_to_starboard;
        }

        //
        // Get the roll angle (but see notes with SetYawAngle() ). If no value was stored for this ping, returns BVT_NAV_NO_DATA.
        //
        // @param degrees_bow_to_starboard yaw angle, in floating point degrees         
        bool TryGetYawAngle(float *degrees_bow_to_starboard)
        {
            int error_code = BVTNavData_GetYawAngle(_owned.get(), degrees_bow_to_starboard);
            if (0 != error_code)
            return true;
            {
                *degrees_bow_to_starboard = 0.0f;
                return false;
            }
        }

        //
        // Returns the Unix epoch time at which the field was set, including fractional seconds. 
        // If no data was stored, the returns zero.
        // NOTE: Timestamps are generated based on the value of the system clock at the time the
        // field was set. As such, they are subject to substantial error due to clock drift and
        // system latency and are in no way synchronized to any global standard. If such synchronization
        // is required, please use the NavTime field and consider using a PPS signal.
        //
        // @param timestamp timestamp in seconds        
        double GetYawAngleTimestamp()
        {
            double timestamp;
            int error_code = BVTNavData_GetYawAngleTimestamp(_owned.get(), /* out */ &timestamp);
            if (0 != error_code)
                throw SdkException(error_code);
            return timestamp;
        }

        //
        // Store the yaw angle. <br>
        // NOTE: This is NOT the same as the Heading field. Heading is for the
        // normal navigation use of Heading, often from a compass. This field is
        // intended to store raw data from other research instruments, in case
        // you need another storage spot. To keep everyone using the fields the
        // same way so that files can be interchanged, please use SetHeading
        // for the normal heading, and SetYawAngle() only for special uses.
        //
        // @param degrees_bow_to_starboard yaw angle, in floating point degrees, to starboard is positive       
        void SetYawAngle(float degrees_bow_to_starboard)
        {
            int error_code = BVTNavData_SetYawAngle(_owned.get(), degrees_bow_to_starboard);
            if (0 != error_code)
                throw SdkException(error_code);
        }

        //
        // Returns the rate of pitch change.
        // If no value was stored for this ping, returns BVT_NAV_NO_DATA.
        //
        // @param degrees_per_second rate of pitch change in degrees per second         
        float GetPitchRate()
        {
            float degrees_per_second;
            int error_code = BVTNavData_GetPitchRate(_owned.get(), /* out */ &degrees_per_second);
            if (0 != error_code)
                throw SdkException(error_code);
            return degrees_per_second;
        }

        //
        // Returns the rate of pitch change.
        // If no value was stored for this ping, returns BVT_NAV_NO_DATA.
        //
        // @param degrees_per_second rate of pitch change in degrees per second         
        bool TryGetPitchRate(float *degrees_per_second)
        {
            int error_code = BVTNavData_GetPitchRate(_owned.get(), degrees_per_second);
            if (0 != error_code)
            return true;
            {
                *degrees_per_second = 0.0f;
                return false;
            }
        }

        //
        // Returns the Unix epoch time at which the field was set, including fractional seconds. 
        // If no data was stored, the returns zero.
        // NOTE: Timestamps are generated based on the value of the system clock at the time the
        // field was set. As such, they are subject to substantial error due to clock drift and
        // system latency and are in no way synchronized to any global standard. If such synchronization
        // is required, please use the NavTime field and consider using a PPS signal.
        //
        // @param timestamp timestamp in seconds        
        double GetPitchRateTimestamp()
        {
            double timestamp;
            int error_code = BVTNavData_GetPitchRateTimestamp(_owned.get(), /* out */ &timestamp);
            if (0 != error_code)
                throw SdkException(error_code);
            return timestamp;
        }

        //
        // Store the the rate of pitch change.
        //
        // @param degrees_per_second rate of pitch change in degrees per second         
        void SetPitchRate(float degrees_per_second)
        {
            int error_code = BVTNavData_SetPitchRate(_owned.get(), degrees_per_second);
            if (0 != error_code)
                throw SdkException(error_code);
        }

        //
        // Returns the rate of roll change.
        // If no value was stored for this ping, returns BVT_NAV_NO_DATA.
        //
        // @param degrees_per_second rate of roll change in degrees per second      
        float GetRollRate()
        {
            float degrees_per_second;
            int error_code = BVTNavData_GetRollRate(_owned.get(), /* out */ &degrees_per_second);
            if (0 != error_code)
                throw SdkException(error_code);
            return degrees_per_second;
        }

        //
        // Returns the rate of roll change.
        // If no value was stored for this ping, returns BVT_NAV_NO_DATA.
        //
        // @param degrees_per_second rate of roll change in degrees per second      
        bool TryGetRollRate(float *degrees_per_second)
        {
            int error_code = BVTNavData_GetRollRate(_owned.get(), degrees_per_second);
            if (0 != error_code)
            return true;
            {
                *degrees_per_second = 0.0f;
                return false;
            }
        }

        //
        // Returns the Unix epoch time at which the field was set, including fractional seconds. 
        // If no data was stored, the returns zero.
        // NOTE: Timestamps are generated based on the value of the system clock at the time the
        // field was set. As such, they are subject to substantial error due to clock drift and
        // system latency and are in no way synchronized to any global standard. If such synchronization
        // is required, please use the NavTime field and consider using a PPS signal.
        //
        // @param timestamp timestamp in seconds        
        double GetRollRateTimestamp()
        {
            double timestamp;
            int error_code = BVTNavData_GetRollRateTimestamp(_owned.get(), /* out */ &timestamp);
            if (0 != error_code)
                throw SdkException(error_code);
            return timestamp;
        }

        //
        // Store the the rate of change in roll.
        //
        // @param degrees_per_second rate of roll change in floating point degrees per second       
        void SetRollRate(float degrees_per_second)
        {
            int error_code = BVTNavData_SetRollRate(_owned.get(), degrees_per_second);
            if (0 != error_code)
                throw SdkException(error_code);
        }

        //
        // Returns the rate of change in yaw (heading).  If no value was stored for this ping,
        // returns BVT_NAV_NO_DATA.
        //
        // @param degrees_per_second rate of yaw change in floating point degrees per second        
        float GetYawRate()
        {
            float degrees_per_second;
            int error_code = BVTNavData_GetYawRate(_owned.get(), /* out */ &degrees_per_second);
            if (0 != error_code)
                throw SdkException(error_code);
            return degrees_per_second;
        }

        //
        // Returns the rate of change in yaw (heading).  If no value was stored for this ping,
        // returns BVT_NAV_NO_DATA.
        //
        // @param degrees_per_second rate of yaw change in floating point degrees per second        
        bool TryGetYawRate(float *degrees_per_second)
        {
            int error_code = BVTNavData_GetYawRate(_owned.get(), degrees_per_second);
            if (0 != error_code)
            return true;
            {
                *degrees_per_second = 0.0f;
                return false;
            }
        }

        //
        // Returns the Unix epoch time at which the field was set, including fractional seconds. 
        // If no data was stored, the returns zero.
        // NOTE: Timestamps are generated based on the value of the system clock at the time the
        // field was set. As such, they are subject to substantial error due to clock drift and
        // system latency and are in no way synchronized to any global standard. If such synchronization
        // is required, please use the NavTime field and consider using a PPS signal.
        //
        // @param timestamp timestamp in seconds        
        double GetYawRateTimestamp()
        {
            double timestamp;
            int error_code = BVTNavData_GetYawRateTimestamp(_owned.get(), /* out */ &timestamp);
            if (0 != error_code)
                throw SdkException(error_code);
            return timestamp;
        }

        //
        // Store the rate of change in yaw (heading).
        //
        // @param degrees_per_second rate of yaw change in floating point degrees per second        
        void SetYawRate(float degrees_per_second)
        {
            int error_code = BVTNavData_SetYawRate(_owned.get(), degrees_per_second);
            if (0 != error_code)
                throw SdkException(error_code);
        }

        //
        // Gets the stored acceleration along the X axis. If no value was stored for this ping,
        // returns BVT_NAV_NO_DATA.
        //
        // @param accel_mg acceleration along X axis, in milli-g        
        float GetAccelerationX()
        {
            float accel_mg;
            int error_code = BVTNavData_GetAccelerationX(_owned.get(), /* out */ &accel_mg);
            if (0 != error_code)
                throw SdkException(error_code);
            return accel_mg;
        }

        //
        // Gets the stored acceleration along the X axis. If no value was stored for this ping,
        // returns BVT_NAV_NO_DATA.
        //
        // @param accel_mg acceleration along X axis, in milli-g        
        bool TryGetAccelerationX(float *accel_mg)
        {
            int error_code = BVTNavData_GetAccelerationX(_owned.get(), accel_mg);
            if (0 != error_code)
            return true;
            {
                *accel_mg = 0.0f;
                return false;
            }
        }

        //
        // Returns the Unix epoch time at which the field was set, including fractional seconds. 
        // If no data was stored, the returns zero.
        // NOTE: Timestamps are generated based on the value of the system clock at the time the
        // field was set. As such, they are subject to substantial error due to clock drift and
        // system latency and are in no way synchronized to any global standard. If such synchronization
        // is required, please use the NavTime field and consider using a PPS signal.
        //
        // @param timestamp timestamp in seconds        
        double GetAccelerationXTimestamp()
        {
            double timestamp;
            int error_code = BVTNavData_GetAccelerationXTimestamp(_owned.get(), /* out */ &timestamp);
            if (0 != error_code)
                throw SdkException(error_code);
            return timestamp;
        }

        //
        // Sets the stored acceleration along the X axis. Intended to store
        // raw values of accelerometers.
        //
        // @param accel_mg acceleration along X axis, in milli-g        
        void SetAccelerationX(float accel_mg)
        {
            int error_code = BVTNavData_SetAccelerationX(_owned.get(), accel_mg);
            if (0 != error_code)
                throw SdkException(error_code);
        }

        //
        // Gets the stored acceleration along the Y axis. If no value was stored for this ping,
        // returns BVT_NAV_NO_DATA.
        //
        // @param accel_mg acceleration along Y axis, in milli-g        
        float GetAccelerationY()
        {
            float accel_mg;
            int error_code = BVTNavData_GetAccelerationY(_owned.get(), /* out */ &accel_mg);
            if (0 != error_code)
                throw SdkException(error_code);
            return accel_mg;
        }

        //
        // Gets the stored acceleration along the Y axis. If no value was stored for this ping,
        // returns BVT_NAV_NO_DATA.
        //
        // @param accel_mg acceleration along Y axis, in milli-g        
        bool TryGetAccelerationY(float *accel_mg)
        {
            int error_code = BVTNavData_GetAccelerationY(_owned.get(), accel_mg);
            if (0 != error_code)
            return true;
            {
                *accel_mg = 0.0f;
                return false;
            }
        }

        //
        // Returns the Unix epoch time at which the field was set, including fractional seconds. 
        // If no data was stored, the returns zero.
        // NOTE: Timestamps are generated based on the value of the system clock at the time the
        // field was set. As such, they are subject to substantial error due to clock drift and
        // system latency and are in no way synchronized to any global standard. If such synchronization
        // is required, please use the NavTime field and consider using a PPS signal.
        //
        // @param timestamp timestamp in seconds        
        double GetAccelerationYTimestamp()
        {
            double timestamp;
            int error_code = BVTNavData_GetAccelerationYTimestamp(_owned.get(), /* out */ &timestamp);
            if (0 != error_code)
                throw SdkException(error_code);
            return timestamp;
        }

        //
        // Sets the stored acceleration along the Y axis. Intended to store
        // raw values of accelerometers.
        //
        // @param accel_mg acceleration along Y axis, in milli-g        
        void SetAccelerationY(float accel_mg)
        {
            int error_code = BVTNavData_SetAccelerationY(_owned.get(), accel_mg);
            if (0 != error_code)
                throw SdkException(error_code);
        }

        //
        // Gets the stored acceleration along the Z axis. If no value was stored for this ping,
        // returns BVT_NAV_NO_DATA.
        //
        // @param accel_mg acceleration along Z axis, in milli-g        
        float GetAccelerationZ()
        {
            float accel_mg;
            int error_code = BVTNavData_GetAccelerationZ(_owned.get(), /* out */ &accel_mg);
            if (0 != error_code)
                throw SdkException(error_code);
            return accel_mg;
        }

        //
        // Gets the stored acceleration along the Z axis. If no value was stored for this ping,
        // returns BVT_NAV_NO_DATA.
        //
        // @param accel_mg acceleration along Z axis, in milli-g        
        bool TryGetAccelerationZ(float *accel_mg)
        {
            int error_code = BVTNavData_GetAccelerationZ(_owned.get(), accel_mg);
            if (0 != error_code)
            return true;
            {
                *accel_mg = 0.0f;
                return false;
            }
        }

        //
        // Returns the Unix epoch time at which the field was set, including fractional seconds. 
        // If no data was stored, the returns zero.
        // NOTE: Timestamps are generated based on the value of the system clock at the time the
        // field was set. As such, they are subject to substantial error due to clock drift and
        // system latency and are in no way synchronized to any global standard. If such synchronization
        // is required, please use the NavTime field and consider using a PPS signal.
        //
        // @param timestamp timestamp in seconds        
        double GetAccelerationZTimestamp()
        {
            double timestamp;
            int error_code = BVTNavData_GetAccelerationZTimestamp(_owned.get(), /* out */ &timestamp);
            if (0 != error_code)
                throw SdkException(error_code);
            return timestamp;
        }

        //
        // Sets the stored acceleration along the Z axis. Intended to store
        // raw values of accelerometers.
        //
        // @param accel_mg acceleration along Z axis, in milli-g        
        void SetAccelerationZ(float accel_mg)
        {
            int error_code = BVTNavData_SetAccelerationZ(_owned.get(), accel_mg);
            if (0 != error_code)
                throw SdkException(error_code);
        }

        //
        // Returns the offset, to the north, from a user-defined fixed point.
        // If no value was stored for this ping, returns BVT_NAV_NO_DATA.
        //
        // @param meters offset to the north, in floating point meters      
        double GetOffsetNorth()
        {
            double meters;
            int error_code = BVTNavData_GetOffsetNorth(_owned.get(), /* out */ &meters);
            if (0 != error_code)
                throw SdkException(error_code);
            return meters;
        }

        //
        // Returns the offset, to the north, from a user-defined fixed point.
        // If no value was stored for this ping, returns BVT_NAV_NO_DATA.
        //
        // @param meters offset to the north, in floating point meters      
        bool TryGetOffsetNorth(double *meters)
        {
            int error_code = BVTNavData_GetOffsetNorth(_owned.get(), meters);
            if (0 != error_code)
            return true;
            {
                *meters = 0.0;
                return false;
            }
        }

        //
        // Returns the Unix epoch time at which the field was set, including fractional seconds. 
        // If no data was stored, the returns zero.
        // NOTE: Timestamps are generated based on the value of the system clock at the time the
        // field was set. As such, they are subject to substantial error due to clock drift and
        // system latency and are in no way synchronized to any global standard. If such synchronization
        // is required, please use the NavTime field and consider using a PPS signal.
        //
        // @param timestamp timestamp in seconds        
        double GetOffsetNorthTimestamp()
        {
            double timestamp;
            int error_code = BVTNavData_GetOffsetNorthTimestamp(_owned.get(), /* out */ &timestamp);
            if (0 != error_code)
                throw SdkException(error_code);
            return timestamp;
        }

        //
        // Store the offset from a user-defined fixed point.
        //
        // @param meters offset to the north, in floating point meters      
        void SetOffsetNorth(double meters)
        {
            int error_code = BVTNavData_SetOffsetNorth(_owned.get(), meters);
            if (0 != error_code)
                throw SdkException(error_code);
        }

        //
        // Returns the offset, to the east, from a user-defined fixed point.
        // If no value was stored for this ping, returns BVT_NAV_NO_DATA.
        //
        // @param meters offset to the east, in floating point meters       
        double GetOffsetEast()
        {
            double meters;
            int error_code = BVTNavData_GetOffsetEast(_owned.get(), /* out */ &meters);
            if (0 != error_code)
                throw SdkException(error_code);
            return meters;
        }

        //
        // Returns the offset, to the east, from a user-defined fixed point.
        // If no value was stored for this ping, returns BVT_NAV_NO_DATA.
        //
        // @param meters offset to the east, in floating point meters       
        bool TryGetOffsetEast(double *meters)
        {
            int error_code = BVTNavData_GetOffsetEast(_owned.get(), meters);
            if (0 != error_code)
            return true;
            {
                *meters = 0.0;
                return false;
            }
        }

        //
        // Returns the Unix epoch time at which the field was set, including fractional seconds. 
        // If no data was stored, the returns zero.
        // NOTE: Timestamps are generated based on the value of the system clock at the time the
        // field was set. As such, they are subject to substantial error due to clock drift and
        // system latency and are in no way synchronized to any global standard. If such synchronization
        // is required, please use the NavTime field and consider using a PPS signal.
        //
        // @param timestamp timestamp in seconds        
        double GetOffsetEastTimestamp()
        {
            double timestamp;
            int error_code = BVTNavData_GetOffsetEastTimestamp(_owned.get(), /* out */ &timestamp);
            if (0 != error_code)
                throw SdkException(error_code);
            return timestamp;
        }

        //
        // Store the offset from a user-defined fixed point.
        //
        // @param meters offset to the east, in floating point meters       
        void SetOffsetEast(double meters)
        {
            int error_code = BVTNavData_SetOffsetEast(_owned.get(), meters);
            if (0 != error_code)
                throw SdkException(error_code);
        }

        //
        // Gets a flag value which indicates if the East and North offset values
        // are from the stored Latitude and Longitude. (see more below...)
        // If no value was stored for this ping, returns BVT_NAV_NO_DATA.
        //
        // @param is_true either 1 or 0, to indicate true or false, respectively        
        int GetOffsetIsFromLatLongFlag()
        {
            int is_true;
            int error_code = BVTNavData_GetOffsetIsFromLatLongFlag(_owned.get(), /* out */ &is_true);
            if (0 != error_code)
                throw SdkException(error_code);
            return is_true;
        }

        //
        // Gets a flag value which indicates if the East and North offset values
        // are from the stored Latitude and Longitude. (see more below...)
        // If no value was stored for this ping, returns BVT_NAV_NO_DATA.
        //
        // @param is_true either 1 or 0, to indicate true or false, respectively        
        bool TryGetOffsetIsFromLatLongFlag(int *is_true)
        {
            int error_code = BVTNavData_GetOffsetIsFromLatLongFlag(_owned.get(), is_true);
            if (0 != error_code)
            return true;
            {
                *is_true = 0;
                return false;
            }
        }

        //
        // Returns the Unix epoch time at which the field was set, including fractional seconds. 
        // If no data was stored, the returns zero.
        // NOTE: Timestamps are generated based on the value of the system clock at the time the
        // field was set. As such, they are subject to substantial error due to clock drift and
        // system latency and are in no way synchronized to any global standard. If such synchronization
        // is required, please use the NavTime field and consider using a PPS signal.
        //
        // @param timestamp timestamp in seconds        
        double GetOffsetIsFromLatLongFlagTimestamp()
        {
            double timestamp;
            int error_code = BVTNavData_GetOffsetIsFromLatLongFlagTimestamp(_owned.get(), /* out */ &timestamp);
            if (0 != error_code)
                throw SdkException(error_code);
            return timestamp;
        }

        //
        // Sets a flag to indicate if the East and North offset values are from
        // the stored Latitude and Longitude. If so, then software reading the
        // file will know to adjust appropriately. If from some special location,
        // perhaps the UserNavString could be used to indicate the reference
        // point? If nothing is stored, then the value is assumed to be false.
        //
        // @param is_true either 1 or 0, to indicate true or false, respectively        
        void SetOffsetIsFromLatLongFlag(int is_true)
        {
            int error_code = BVTNavData_SetOffsetIsFromLatLongFlag(_owned.get(), is_true);
            if (0 != error_code)
                throw SdkException(error_code);
        }

        //
        // Returns the stored user string, in null-terminated form. If no
        // string was stored, returns a null string.
        //
        // @param navString user-defined description string 
        // @param bufferLength length of navString buffer (in bytes)        
        std::string GetUserNavString()
        {
            char navString[256] = { 0 };
            int bufferLength = 255;
            int error_code = BVTNavData_GetUserNavString(_owned.get(), navString, bufferLength);
            if (0 != error_code)
                throw SdkException(error_code);
            return std::string(navString);
        }

        //
        // Returns the Unix epoch time at which the field was set, including fractional seconds. 
        // If no data was stored, the returns zero.
        // NOTE: Timestamps are generated based on the value of the system clock at the time the
        // field was set. As such, they are subject to substantial error due to clock drift and
        // system latency and are in no way synchronized to any global standard. If such synchronization
        // is required, please use the NavTime field and consider using a PPS signal.
        //
        // @param timestamp timestamp in seconds        
        double GetUserNavStringTimestamp()
        {
            double timestamp;
            int error_code = BVTNavData_GetUserNavStringTimestamp(_owned.get(), /* out */ &timestamp);
            if (0 != error_code)
                throw SdkException(error_code);
            return timestamp;
        }

        //
        // Stores a user-defined string related to navigation. It is highly
        // recommended to store some identifier such that the data is
        // recognizable as you own. <br>
        // Examples of possible uses might be to store locations based on 
        // coordinate systems other than GPS, indicating information about
        // the use of the north and east offset parameters, additional fields
        // from a GPS receiver, or any other information which might change
        // dynamically.
        //
        // @param string_in string to be stored, null terminated, max length 80 chars       
        void SetUserNavString(const std::string & string_in)
        {
            int error_code = BVTNavData_SetUserNavString(_owned.get(), string_in.c_str());
            if (0 != error_code)
                throw SdkException(error_code);
        }

        //
        // Returns the stored Source string, in null-terminated form. If no
        // string was stored, returns a null string.
        //
        // @param source_string The source string.  
        // @param source_string_length The length in characters of the Source string.       
        std::string GetSource()
        {
            char source_string[256] = { 0 };
            int source_string_length = 255;
            int error_code = BVTNavData_GetSource(_owned.get(), source_string, source_string_length);
            if (0 != error_code)
                throw SdkException(error_code);
            return std::string(source_string);
        }

        //
        // Returns the length of the stored Source string.
        //
        // @param source_string_length The length in characters of the stored Source string.        
        int GetSourceLength()
        {
            int source_string_length;
            int error_code = BVTNavData_GetSourceLength(_owned.get(), /* out */ &source_string_length);
            if (0 != error_code)
                throw SdkException(error_code);
            return source_string_length;
        }

        //
        // Returns the Unix epoch time at which the field was set, including fractional seconds. 
        // If no data was stored, the returns zero.
        // NOTE: Timestamps are generated based on the value of the system clock at the time the
        // field was set. As such, they are subject to substantial error due to clock drift and
        // system latency and are in no way synchronized to any global standard. If such synchronization
        // is required, please use the NavTime field and consider using a PPS signal.
        //
        // @param timestamp timestamp in seconds        
        double GetSourceTimestamp()
        {
            double timestamp;
            int error_code = BVTNavData_GetSourceTimestamp(_owned.get(), /* out */ &timestamp);
            if (0 != error_code)
                throw SdkException(error_code);
            return timestamp;
        }

        //
        // Stores a user-defined string which identifies the NavData source, 
        // e.g. "MRU", "GPS", "Compass". <br>.
        //
        // @param source_string string to be stored, null terminated, max length 80 chars       
        void SetSource(const std::string & source_string)
        {
            int error_code = BVTNavData_SetSource(_owned.get(), source_string.c_str());
            if (0 != error_code)
                throw SdkException(error_code);
        }

        //
        // Returns the stored UTM zone and grid number, in null-terminated form. If no
        // string was stored, returns a null string.
        //
        // @param zone output char buffer to hold zone string
        // @param bufLength total length of zone buffer (in bytes)      
        std::string GetUTMLongitudeZone()
        {
            char zone[256] = { 0 };
            int bufLength = 255;
            int error_code = BVTNavData_GetUTMLongitudeZone(_owned.get(), zone, bufLength);
            if (0 != error_code)
                throw SdkException(error_code);
            return std::string(zone);
        }

        //
        // Returns the Unix epoch time at which the field was set, including fractional seconds. 
        // If no data was stored, the returns zero.
        // NOTE: Timestamps are generated based on the value of the system clock at the time the
        // field was set. As such, they are subject to substantial error due to clock drift and
        // system latency and are in no way synchronized to any global standard. If such synchronization
        // is required, please use the NavTime field and consider using a PPS signal.
        //
        // @param timestamp timestamp in seconds        
        double GetUTMLongitudeZoneTimestamp()
        {
            double timestamp;
            int error_code = BVTNavData_GetUTMLongitudeZoneTimestamp(_owned.get(), /* out */ &timestamp);
            if (0 != error_code)
                throw SdkException(error_code);
            return timestamp;
        }

        //
        // Stores a string which identifies the UTM Zone and grid used as the
        // basis for Northing and Easting values. Zones range from [1,60], grids are lettered from
        // C-X not including O or I. Acceptable strings are of the form "1G" or "03F" or "54T".
        //
        // @param zone_string zone and grid to be stored, null terminated. Should be either 2 or 3 characters       
        void SetUTMLongitudeZone(const std::string & zone_string)
        {
            int error_code = BVTNavData_SetUTMLongitudeZone(_owned.get(), zone_string.c_str());
            if (0 != error_code)
                throw SdkException(error_code);
        }

        //
        // Stores a heave value, which is expected to be supplied by an MRU.
        //
        // @param heave_in_meters       
        void SetHeave(float heave_in_meters)
        {
            int error_code = BVTNavData_SetHeave(_owned.get(), heave_in_meters);
            if (0 != error_code)
                throw SdkException(error_code);
        }

        //
        // Returns the Unix epoch time at which the field was set, including fractional seconds. 
        // If no data was stored, the returns zero.
        // NOTE: Timestamps are generated based on the value of the system clock at the time the
        // field was set. As such, they are subject to substantial error due to clock drift and
        // system latency and are in no way synchronized to any global standard. If such synchronization
        // is required, please use the NavTime field and consider using a PPS signal.
        //
        // @param timestamp timestamp in seconds        
        double GetHeaveTimestamp()
        {
            double timestamp;
            int error_code = BVTNavData_GetHeaveTimestamp(_owned.get(), /* out */ &timestamp);
            if (0 != error_code)
                throw SdkException(error_code);
            return timestamp;
        }

        //
        // Gets the stored heave. If no value was stored for this ping,
        // returns BVT_NAV_NO_DATA.
        //
        // @param heave_in_meters Returns the heave in meters.      
        float GetHeave()
        {
            float heave_in_meters;
            int error_code = BVTNavData_GetHeave(_owned.get(), /* out */ &heave_in_meters);
            if (0 != error_code)
                throw SdkException(error_code);
            return heave_in_meters;
        }

        //
        // Gets the stored heave. If no value was stored for this ping,
        // returns BVT_NAV_NO_DATA.
        //
        // @param heave_in_meters Returns the heave in meters.      
        bool TryGetHeave(float *heave_in_meters)
        {
            int error_code = BVTNavData_GetHeave(_owned.get(), heave_in_meters);
            if (0 != error_code)
            return true;
            {
                *heave_in_meters = 0.0f;
                return false;
            }
        }

        //
        // Return the data's timestamp in seconds since 00:00:00 UTC, January 1, 1970 
        // NavData is timestamped using a standard UNIX time stamp. This is 
        // a similar value to that returned by the time() C standard library 
        // function. In fact, the only difference is the addition of fractional seconds.
        //
        // @param seconds navigation timestamp in seconds       
        double GetNavTime()
        {
            double seconds;
            int error_code = BVTNavData_GetNavTime(_owned.get(), /* out */ &seconds);
            if (0 != error_code)
                throw SdkException(error_code);
            return seconds;
        }

        //
        // Return the data's timestamp in seconds since 00:00:00 UTC, January 1, 1970 
        // NavData is timestamped using a standard UNIX time stamp. This is 
        // a similar value to that returned by the time() C standard library 
        // function. In fact, the only difference is the addition of fractional seconds.
        //
        // @param seconds navigation timestamp in seconds       
        bool TryGetNavTime(double *seconds)
        {
            int error_code = BVTNavData_GetNavTime(_owned.get(), seconds);
            if (0 != error_code)
            return true;
            {
                *seconds = 0.0;
                return false;
            }
        }

        //
        // Returns the Unix epoch time at which the field was set, including fractional seconds. 
        // If no data was stored, the returns zero.
        // This field may be compared to the output of GetNavTime() to get a temporary estimate of the offset
        // between the system clock and the device clock. Note that this estimate will be subeject to 
        // drift.
        // NOTE: Timestamps are generated based on the value of the system clock at the time the
        // field was set. As such, they are subject to substantial error due to clock drift and
        // system latency and are in no way synchronized to any global standard. If such synchronization
        // is required, please use the NavTime field and consider using a PPS signal.
        //
        // @param timestamp timestamp in seconds        
        double GetNavTimeTimestamp()
        {
            double timestamp;
            int error_code = BVTNavData_GetNavTimeTimestamp(_owned.get(), /* out */ &timestamp);
            if (0 != error_code)
                throw SdkException(error_code);
            return timestamp;
        }

        //
        // Set the NavData's internal time stamp.  See GetNavTime() for more information. 
        //
        // @param sec Timestamp in seconds since 00:00:00 UTC, January 1, 1970      
        void SetNavTime(double sec)
        {
            int error_code = BVTNavData_SetNavTime(_owned.get(), sec);
            if (0 != error_code)
                throw SdkException(error_code);
        }

    };

}

#endif
