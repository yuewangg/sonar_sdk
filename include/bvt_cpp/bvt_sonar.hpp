/*
    This file has been generated by bvtidl.pl. DO NOT MODIFY!
*/

#ifndef __CPP_BVTSONAR_HPP__
#define __CPP_BVTSONAR_HPP__

#include "bvt_triggeroutputevent.hpp"
#include <string>
#ifdef _WIN32
#   include <memory>
#else
#   include <cstddef>
#   if defined (__GLIBCXX__) && __cplusplus <= 199711L
#      include <tr1/memory>
       namespace std {
          using std::tr1::shared_ptr;
       }
#   else
#       include <memory>
#   endif
#endif
#include <bvt_cpp/bvt_retval.hpp>
#include <bvt_cpp/bvt_error.hpp>
#include <bvt_cpp/bvt_ping.hpp>
#include <bvt_cpp/bvt_head.hpp>
#include <bvt_cpp/bvt_navdata.hpp>
#include <bvt_cpp/bvt_orientation.hpp>
#include <bvt_cpp/bvt_eventmark.hpp>
#include <bvt_cpp/bvt_networksettings.hpp>

namespace BVTSDK
{

    class EventMark;
    class NetworkSettings;
    class Orientation;
    class Head;
    class NavData;
    class Ping;

    /// <summary>
    /// The Sonar object is the top level object in the SDK.  A sonar 
    /// object embodies communication with a single physical sonar unit,
    /// or file.  Each sonar contains several heads, which is where most
    /// of the functionality is implemented.  Sonar also provides a
    /// function to create new data files using BlueView's .son format.
    /// <summary>
    class Sonar
    {
    public:
        Sonar()
        {
            BVTSonar p = BVTSonar_Create();
            _owned = std::shared_ptr<BVTOpaqueSonar>(p , BVTSonar_Destroy );
        }
    public: /*consider private*/
        Sonar(BVTSonar p)
        {
            _owned = std::shared_ptr<BVTOpaqueSonar>(p , BVTSonar_Destroy );
        }
    public:
        ~Sonar()
        {
            
        }

    //public:
    //  Sonar(const Sonar &) {}
    //  Sonar& operator=(const Sonar &) {}
    public:
        /// SDK object pointer
        BVTSonar Handle() const
        {
            return _owned.get();
        }
    private:
        std::shared_ptr<BVTOpaqueSonar> _owned;

    public:
        //
        // Open the sonar type 'type' using the specified parameters.
        // Allowed types (and parameters):
        // - FILE <br>
        // [filename] - Required <br>
        // - NET <br>
        // [host] - Connect to the specified host.<br>
        // - CFILE <br>
        // [files] - semicolon delimited list of files to play as composite sonar<br>
        // - COMP <br>
        // [hosts] - semicolon delimited list of files hosts to connect to.
        // of each host all heads will be used.<br>
        //
        // @param type The type of sonar to open    
        // @param type_params Various type-specific parameters      
        void Open(const std::string & type, const std::string & type_params)
        {
            int error_code = BVTSonar_Open(_owned.get(), type.c_str(), type_params.c_str());
            if (0 != error_code)
                throw SdkException(error_code);
        }

        //
        // Create a new data file.
        // Files are always created by 'cloning' another Sonar
        // object.  This ensures that the file receives all the
        // needed configuration data needed to process 
        // images.
        //
        // @param file_name The filename of the file to be created 
        // @param src The Sonar object to clone when creating the file 
        // @param create_params Parameters for (reserved for future use)        
        void CreateFile(const std::string & file_name, const Sonar & src, const std::string & create_params)
        {
            int error_code = BVTSonar_CreateFile(_owned.get(), file_name.c_str(), src.Handle(), create_params.c_str());
            if (0 != error_code)
                throw SdkException(error_code);
        }

        //
        // Return the serial 'number' of the sonar. The string may contain non-numeric characters.
        //
        // @param buffer buffer to hold the null-terminated string to be passed back 
        // @param buffer_size total number of characters the passed buffer can hold         
        std::string GetSerialNumber()
        {
            char buffer[256] = { 0 };
            int buffer_size = 255;
            int error_code = BVTSonar_GetSerialNumber(_owned.get(), buffer, buffer_size);
            if (0 != error_code)
                throw SdkException(error_code);
            return std::string(buffer);
        }

        //
        // Return the firmware revision of the sonar. The string may contain non-numeric characters.
        //
        // @param buffer buffer to hold the null-terminated string to be passed back 
        // @param buffer_size total number of characters the passed buffer can hold         
        std::string GetFirmwareRevision()
        {
            char buffer[256] = { 0 };
            int buffer_size = 255;
            int error_code = BVTSonar_GetFirmwareRevision(_owned.get(), buffer, buffer_size);
            if (0 != error_code)
                throw SdkException(error_code);
            return std::string(buffer);
        }

        //
        // Returns True if this sonar is associated with a file.
        //
        // @param is_file True if this sonar is associated with a file      
        bool IsFile()
        {
            int is_file;
            int error_code = BVTSonar_IsFile(_owned.get(), /* out */ &is_file);
            if (0 != error_code)
                throw SdkException(error_code);
            return is_file > 0;
        }

        //
        // Returns True if this sonar file has raw ping data.
        //
        // @param file_has_raw_ping_data True if this sonar file has raw ping data      
        bool FileHasRawPingData()
        {
            int file_has_raw_ping_data;
            int error_code = BVTSonar_FileHasRawPingData(_owned.get(), /* out */ &file_has_raw_ping_data);
            if (0 != error_code)
                throw SdkException(error_code);
            return file_has_raw_ping_data > 0;
        }

        //
        // Returns True if this sonar is networked and connected.
        //
        // @param is_connected True if this sonar is networked and connected.       
        bool IsConnected()
        {
            int is_connected;
            int error_code = BVTSonar_IsConnected(_owned.get(), /* out */ &is_connected);
            if (0 != error_code)
                throw SdkException(error_code);
            return is_connected > 0;
        }

        //
        // Returns True if this sonar is networked and supports multicast pings.
        //
        // @param is_multicast True if this sonar is networked and supports multicast pings         
        bool SupportsMulticast()
        {
            int is_multicast;
            int error_code = BVTSonar_SupportsMulticast(_owned.get(), /* out */ &is_multicast);
            if (0 != error_code)
                throw SdkException(error_code);
            return is_multicast > 0;
        }

        //
        // Removes all user settings stored on the sonar and reverts the unit back to
        // its original factory configuration.  IP address of the unit after calling 
        // this function will be 192.168.1.45, while other parameters depend on the type of
        // sonar.
        //      
        void RevertFactorySettings()
        {
            int error_code = BVTSonar_RevertFactorySettings(_owned.get());
            if (0 != error_code)
                throw SdkException(error_code);
        }

        //
        // Gets the size of a file created with CreateFile(). Only works with
        // file type sonars. A networked sonar will return 0, as will a file
        // type sonar if there is no open file associated with it.
        // The return value must be multiplied by 1000 to get the actual
        // file size in bytes.
        //
        // @param fileSize Size (in bytes) of the file sonar        
        int GetFileSize()
        {
            int fileSize;
            int error_code = BVTSonar_GetFileSize(_owned.get(), /* out */ &fileSize);
            if (0 != error_code)
                throw SdkException(error_code);
            return fileSize;
        }

        //
        // Return the number of time indexed pings in this file.
        //
        // @param count Number of time-indexed pings        
        int GetTimeIndexedPingCount()
        {
            int count;
            int error_code = BVTSonar_GetTimeIndexedPingCount(_owned.get(), /* out */ &count);
            if (0 != error_code)
                throw SdkException(error_code);
            return count;
        }

        //
        // Retrieve a ping from the file, using the time index.
        // The Ping will have the same Head parent that it was acquired with.
        // If this function is called on a "live" sonar (network),
        // then it always returns the FAILED (1) error.
        //
        // @param ping_num The ping number to return 
        // @param ping The returned Ping object     
        Ping GetTimeIndexedPing(int ping_num)
        {
            BVTPing ping_ptr = NULL;
            int error_code = BVTSonar_GetTimeIndexedPing(_owned.get(), ping_num, & ping_ptr);
            if (0 != error_code)
                throw SdkException(error_code);
            return Ping(ping_ptr);
        }

        //
        // Retrieve a Head object from the sonar
        //
        // @param head_num The head number to return 
        // @param head The returned Head object         
        Head GetHead(int head_num)
        {
            BVTHead head_ptr = NULL;
            int error_code = BVTSonar_GetHead(_owned.get(), head_num, & head_ptr);
            if (0 != error_code)
                throw SdkException(error_code);
            return Head(head_ptr);
        }

        //
        // Return the number of heads on this sonar.
        //
        // @param head_count Number of heads        
        int GetHeadCount()
        {
            int head_count;
            int error_code = BVTSonar_GetHeadCount(_owned.get(), /* out */ &head_count);
            if (0 != error_code)
                throw SdkException(error_code);
            return head_count;
        }

        //
        // Retrieves a copy of a short string with the model of the sonar.
        // At the time of this writing, 20 characters would easily hold all of
        // the sonar model names.
        //
        // @param buffer buffer to hold the null-terminated string to be passed back 
        // @param buffer_size total number of characters the passed buffer can hold         
        std::string GetSonarModelName()
        {
            char buffer[256] = { 0 };
            int buffer_size = 255;
            int error_code = BVTSonar_GetSonarModelName(_owned.get(), buffer, buffer_size);
            if (0 != error_code)
                throw SdkException(error_code);
            return std::string(buffer);
        }

        //
        // Retrieves a copy of the user-overridable name of the sonar. <br> 
        // The name is set at the factory but is separate from any BlueView model designations. <br>
        //
        // @param buffer buffer to hold the null-terminated string to be passed back 
        // @param buffer_size total number of characters the passed buffer can hold         
        std::string GetSonarName()
        {
            char buffer[256] = { 0 };
            int buffer_size = 255;
            int error_code = BVTSonar_GetSonarName(_owned.get(), buffer, buffer_size);
            if (0 != error_code)
                throw SdkException(error_code);
            return std::string(buffer);
        }

        //
        // 
        //
        // @param name buffer with the null-terminated string name to be set.       
        void SetSonarName(const std::string & name)
        {
            int error_code = BVTSonar_SetSonarName(_owned.get(), name.c_str());
            if (0 != error_code)
                throw SdkException(error_code);
        }

        //
        // Return the sonar's internal temperature in degrees Celsius
        //
        // @param temperature temperature       
        float GetTemperature()
        {
            float temperature;
            int error_code = BVTSonar_GetTemperature(_owned.get(), /* out */ &temperature);
            if (0 != error_code)
                throw SdkException(error_code);
            return temperature;
        }

        //
        // Return the sonar's internal temperature in degrees Celsius
        //
        // @param temperature temperature       
        bool TryGetTemperature(float *temperature)
        {
            int error_code = BVTSonar_GetTemperature(_owned.get(), temperature);
            if (0 != error_code)
            return true;
            {
                *temperature = 0.0f;
                return false;
            }
        }

        //
        // Write the object to a file.  Note that this object is not associated with a Ping.
        //
        // @param nav_data The Navigation data object to write out      
        void PutNavData(const NavData & nav_data)
        {
            int error_code = BVTSonar_PutNavData(_owned.get(), nav_data.Handle());
            if (0 != error_code)
                throw SdkException(error_code);
        }

        //
        // Returns the number of NavData objects in this file.  This count does not include any NavData objects that were written to the file as part of a Ping.
        //
        // @param count NavData count       
        int GetNavDataCount()
        {
            int count;
            int error_code = BVTSonar_GetNavDataCount(_owned.get(), /* out */ &count);
            if (0 != error_code)
                throw SdkException(error_code);
            return count;
        }

        //
        // Retrieve a NavData object from the file.
        // The index is zero-based, that is, if GetNavDataCount() returned a value of 3, then valid indices are 0, 1, and 2.
        //
        // @param index index of NavData to return 
        // @param nav_data The returned NavData object      
        NavData GetNavDataCopy(int index)
        {
            BVTNavData nav_data_ptr = NULL;
            int error_code = BVTSonar_GetNavDataCopy(_owned.get(), index, & nav_data_ptr);
            if (0 != error_code)
                throw SdkException(error_code);
                        return NavData(nav_data_ptr);
        }

        //
        // Write the object to a file.  Note that this object is not associated with a Ping.
        //
        // @param orient The Orientation data object to write out       
        void PutOrientation(const Orientation & orient)
        {
            int error_code = BVTSonar_PutOrientation(_owned.get(), orient.Handle());
            if (0 != error_code)
                throw SdkException(error_code);
        }

        //
        // Returns the number of Orientation objects in this file.  This count does not include any Orientation objects that were written to the file as part of a Ping or a Head.
        //
        // @param count number of orientation objects       
        int GetOrientationCount()
        {
            int count;
            int error_code = BVTSonar_GetOrientationCount(_owned.get(), /* out */ &count);
            if (0 != error_code)
                throw SdkException(error_code);
            return count;
        }

        //
        // Retrieve a Orientation object from the file.
        // The index is zero-based, that is, if GetlOrientationCount() returned a value of 3, then valid indices are 0, 1, and 2.
        //
        // @param index index of Orientation to return 
        // @param orient The returned Orientation object        
        Orientation GetOrientationCopy(int index)
        {
            BVTOrientation orient_ptr = NULL;
            int error_code = BVTSonar_GetOrientationCopy(_owned.get(), index, & orient_ptr);
            if (0 != error_code)
                throw SdkException(error_code);
                        return Orientation(orient_ptr);
        }

        //
        // Creates and writes an EventMark to the current file.
        // The key string contains arbitrary user-defined text. The maximum length is ::BVTEVENTMARK_MAX_KEYLENGTH characters.
        // The text string contains arbitrary user-defined text. The maximum length is ::BVTEVENTMARK_MAX_TEXTLENGTH characters.
        // These strings provide a means to store raw data strings from various sensors such as a GPS or compass.
        // The Key string would be used to identify the device, e.g. "GPS", and the data string ("sentence") from 
        // the device would be stored in the Text string.
        // Note that the EventMark is not associated with a Ping.
        //
        // @param key null-terminated character string 
        // @param text null-terminated character string         
        void PutEventMark(const std::string & key, const std::string & text)
        {
            int error_code = BVTSonar_PutEventMark(_owned.get(), key.c_str(), text.c_str());
            if (0 != error_code)
                throw SdkException(error_code);
        }

        //
        // Returns the number of EventMark objects in this file.  
        //
        // @param count number of event marks       
        int GetEventMarkCount()
        {
            int count;
            int error_code = BVTSonar_GetEventMarkCount(_owned.get(), /* out */ &count);
            if (0 != error_code)
                throw SdkException(error_code);
            return count;
        }

        //
        // Retrieve an EventMark object from the file.
        // The index is zero-based, that is, if GetEventMarkCount returned a value of 3, then valid indices are 0, 1, and 2.
        //
        // @param index index of EventMark to return 
        // @param em The returned EventMark object      
        EventMark GetEventMarkCopy(int index)
        {
            BVTEventMark em_ptr = NULL;
            int error_code = BVTSonar_GetEventMarkCopy(_owned.get(), index, & em_ptr);
            if (0 != error_code)
                throw SdkException(error_code);
                        return EventMark(em_ptr);
        }

        //
        // Get the network settings of this Sonar.
        // The settings may not be valid until this Sonar is restarted.
        //
        // @param settings Allocated by this function.  Caller must destroy when done.      
        NetworkSettings GetNetworkSettings()
        {
            BVTNetworkSettings settings_ptr = NULL;
            int error_code = BVTSonar_GetNetworkSettings(_owned.get(), & settings_ptr);
            if (0 != error_code)
                throw SdkException(error_code);
                        return NetworkSettings(settings_ptr);
        }

        //
        // Set the network settings of this sonar. 
        // These settings will not be valid unti this Sonar is restarted.
        //
        // @param settings The network settings to apply to this Sonar.         
        void SetNetworkSettings(const NetworkSettings & settings)
        {
            int error_code = BVTSonar_SetNetworkSettings(_owned.get(), settings.Handle());
            if (0 != error_code)
                throw SdkException(error_code);
        }

        //
        // Set to true to modify ping timestamps by the local computer's (running the SDK) clock.
        // \attention Disable if this Sonar is connected to a pulse-per-second (PPS) signal.
        //
        // @param enable True to modify ping timestamps by the local clock      
        void SetTimestampsUseLocalClock(bool enable)
        {
            int error_code = BVTSonar_SetTimestampsUseLocalClock(_owned.get(), (enable ? 1 : 0));
            if (0 != error_code)
                throw SdkException(error_code);
        }

        //
        // Returns true if ping timestamps are modified by the local computer's (running the SDK) clock.
        //
        // @param is_enabled True if ping timestamps are modified by the local clock        
        bool GetTimestampsUseLocalClock()
        {
            int is_enabled;
            int error_code = BVTSonar_GetTimestampsUseLocalClock(_owned.get(), /* out */ &is_enabled);
            if (0 != error_code)
                throw SdkException(error_code);
            return is_enabled > 0;
        }

        //
        // Generates a new file containing the current configuration of the sonar.  
        // The output should be sent to BlueView for analysis and is intended for diagnostic purposes.
        //
        // @param file The name of the file that will contain string        
        void DumpToFile(const std::string & file)
        {
            int error_code = BVTSonar_DumpToFile(_owned.get(), file.c_str());
            if (0 != error_code)
                throw SdkException(error_code);
        }

        //
        // Indicates whether this sonar supports target tracking.
        //
        // @param supported true (1) if tracking supported, false (0) otherwise     
        bool SupportsTargetTracking()
        {
            int supported;
            int error_code = BVTSonar_SupportsTargetTracking(_owned.get(), /* out */ &supported);
            if (0 != error_code)
                throw SdkException(error_code);
            return supported > 0;
        }

        //
        // Latest generation BlueView sonar support source level (transmit power) control. This calls allows users to ascertain whether the sonar supports the source level control functionality.
        //
        // @param supported true (1) if supported, false (0) if unsupported         
        bool SupportsSourceLevelControl()
        {
            int supported;
            int error_code = BVTSonar_SupportsSourceLevelControl(_owned.get(), /* out */ &supported);
            if (0 != error_code)
                throw SdkException(error_code);
            return supported > 0;
        }

        //
        // Set the sonar's transmit source level, only found on newer hardware. This will always disable the auto source level mode.
        //
        // @param level Ratio of desired value to max (0.0 to 1.0)      
        void SetSourceLevel(float level)
        {
            int error_code = BVTSonar_SetSourceLevel(_owned.get(), level);
            if (0 != error_code)
                throw SdkException(error_code);
        }

        //
        // Get the sonar's source level (transmit power), only found on newer hardware.
        //
        // @param level See SetSourceLevel      
        float GetSourceLevel()
        {
            float level;
            int error_code = BVTSonar_GetSourceLevel(_owned.get(), /* out */ &level);
            if (0 != error_code)
                throw SdkException(error_code);
            return level;
        }

        //
        // Sonar that support source level control can be configured to automatically adjust the source level based on the current configured max range. This call allows users to enable/disable this feature. 
        //
        // @param enable true (1) to enable, false (0) to disable       
        void EnableAutoSourceLevel(bool enable)
        {
            int error_code = BVTSonar_EnableAutoSourceLevel(_owned.get(), (enable ? 1 : 0));
            if (0 != error_code)
                throw SdkException(error_code);
        }

        //
        // Indicates whether sonar is configured to use automatic source level control.
        //
        // @param enabled true (1) if enabled, false (0) if disabled        
        bool IsAutoSourceLevelEnabled()
        {
            int enabled;
            int error_code = BVTSonar_IsAutoSourceLevelEnabled(_owned.get(), /* out */ &enabled);
            if (0 != error_code)
                throw SdkException(error_code);
            return enabled > 0;
        }

        //
        // Return true if this sonar's hardware and firmware combination supports a hardware trigger.
        // \warning This function will return true even if a hardware trigger is NOT physically connected to the sonar but the firmware does support triggering.
        // \warning This function will return false even if you physically connect a hardware trigger but the firmware
        // does not support triggering.
        //
        // @param supported True if this sonar's hardware and firmware combination supports a hardware trigger.         
        bool SupportsExternalHardwareTrigger()
        {
            int supported;
            int error_code = BVTSonar_SupportsExternalHardwareTrigger(_owned.get(), /* out */ &supported);
            if (0 != error_code)
                throw SdkException(error_code);
            return supported > 0;
        }

        //
        // Enables the sonar to ping on receipt of an external trigger signal. Note that 
        // this requires a sonar equipped with a hardware trigger.
        // \warning Enabling this option on an unsupported sonar will cause it to stop
        // pinging until the option is turned off.
        // \warning Enabling external triggering will override any previous setting to
        // enable hardware trigger output. (These are mutually exclusive settings)
        //
        // @param delay Delay in millseconds between trigger pulse and pulse transmit.      
        void EnableExternalHardwareTrigger(int delay)
        {
            int error_code = BVTSonar_EnableExternalHardwareTrigger(_owned.get(), delay);
            if (0 != error_code)
                throw SdkException(error_code);
        }

        //
        // Turns hardware triggering off. 
        //      
        void DisableExternalHardwareTrigger()
        {
            int error_code = BVTSonar_DisableExternalHardwareTrigger(_owned.get());
            if (0 != error_code)
                throw SdkException(error_code);
        }

        //
        // Enables the sonar to generate a 1 millisecond pulse on the hardware
        // trigger line whenever the trigger event occurs. This provides a
        // synchronization capability via hardware for multi-sensor systems. The trigger event
        // may be specified as the beginning of acoustic transmit, the end of acoustic transmit,
        // or the end of data acquisition.
        // \warning Enabling hardware trigger output will override any previous 
        // setting to enable external hardware trigger. (These are mutually exclusive settings)
        //
        // @param triggerEvent The event in the ping cycle that will induce the trigger signal      
        void EnableExternalHardwareTriggerOutput(enum TriggerOutputEvent::Enum triggerEvent)
        {
            int error_code = BVTSonar_EnableExternalHardwareTriggerOutput(_owned.get(), ((int) triggerEvent));
            if (0 != error_code)
                throw SdkException(error_code);
        }

        //
        // Queries whether hardware trigger is enabled. It is only valid for sonars equipped
        // with a hardware trigger.
        //
        // @param enabled On return specifies whether hardware trigger is enabled       
        bool GetExternalHardwareTriggerEnabled()
        {
            int enabled;
            int error_code = BVTSonar_GetExternalHardwareTriggerEnabled(_owned.get(), /* out */ &enabled);
            if (0 != error_code)
                throw SdkException(error_code);
            return enabled > 0;
        }

        //
        // Queries the direction (input or output) of the hardware trigger. A hardware trigger
        // configured as input indicates that the sonar pings only on receipt of a trigger pulse.
        // A hardware trigger configured as output indicates that the sonar will emit a trigger
        // pulse during each ping. See TriggerOutputEvent for the list of events in a ping 
        // sequence that can be configured as the pulse trigger event. This function is only
        //
        // @param is_input On return specifies hardware trigger direction       
        bool GetExternalHardwareTriggerDirection()
        {
            int is_input;
            int error_code = BVTSonar_GetExternalHardwareTriggerDirection(_owned.get(), /* out */ &is_input);
            if (0 != error_code)
                throw SdkException(error_code);
            return is_input > 0;
        }

        //
        // Only valid if the hardware trigger is configured as an input. See EnableExternalHardwareTrigger
        //
        // @param delay_in_ms On return specfies the hardware trigger ping delay in milliseconds        
        int GetExternalHardwareTriggerInputDelay()
        {
            int delay_in_ms;
            int error_code = BVTSonar_GetExternalHardwareTriggerInputDelay(_owned.get(), /* out */ &delay_in_ms);
            if (0 != error_code)
                throw SdkException(error_code);
            return delay_in_ms;
        }

        //
        // Only valid if the hardware trigger is configure as an output. 
        // See EnableExternalHardwareTriggerOutput
        //
        // @param triggerEvent On return specifies the output trigger event         
        enum TriggerOutputEvent::Enum GetExternalHardwareTriggerOutputEvent()
        {
            int triggerEvent;
            int error_code = BVTSonar_GetExternalHardwareTriggerOutputEvent(_owned.get(), /* out */ &triggerEvent);
            if (0 != error_code)
                throw SdkException(error_code);
            return (enum TriggerOutputEvent::Enum) triggerEvent;
        }

    };

}

#endif
