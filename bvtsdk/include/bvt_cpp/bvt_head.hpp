/*
    This file has been generated by bvtidl.pl. DO NOT MODIFY!
*/

#ifndef __CPP_BVTHEAD_HPP__
#define __CPP_BVTHEAD_HPP__

#include "bvt_fluidtype.hpp"
#include "bvt_imageprocessingmethod.hpp"
#include "bvt_imageres.hpp"
#include "bvt_imagefilterflags.hpp"
#include "bvt_mountside.hpp"
#include "bvt_mounttype.hpp"
#include "bvt_imagetype.hpp"
#include <string>
#ifdef _WIN32
#   include <memory>
#else
#   include <cstddef>
#   if defined (__GLIBCXX__) && __cplusplus <= 199711L
#      include <tr1/memory>
       namespace std {
          using std::tr1::shared_ptr;
       }
#   else
#       include <memory>
#   endif
#endif
#include <bvt_cpp/bvt_retval.hpp>
#include <bvt_cpp/bvt_error.hpp>
#include <bvt_cpp/bvt_ping.hpp>
#include <bvt_cpp/bvt_orientation.hpp>

namespace BVTSDK
{

    class Ping;
    class Orientation;

    /// <summary>
    /// A head consists of a group of co-planar transducers which are
    /// operated simultaneously to produce (ultimately) a single 2d
    /// image.  The Head object provides functions to change the 
    /// range window as well as produce pings.
    /// <summary>
    class Head
    {
    public:
    public: /*consider private*/
        Head(BVTHead p)
        {
            _owned = std::shared_ptr<BVTOpaqueHead>(p , BVTHead_Destroy );
        }
    public:
        ~Head()
        {
            
        }

    //public:
    //  Head(const Head &) {}
    //  Head& operator=(const Head &) {}
    public:
        /// SDK object pointer
        BVTHead Handle() const
        {
            return _owned.get();
        }
    private:
        std::shared_ptr<BVTOpaqueHead> _owned;

    //  Sonar Sonar() const
    //  {
    //      return *_parent;
    //  }
    // private:
    //  Sonar *_parent;

    public:
        //
        // Retrieve the Head's ID.
        //
        // @param headId ID for this head       
        int GetHeadID()
        {
            int headId;
            int error_code = BVTHead_GetHeadID(_owned.get(), /* out */ &headId);
            if (0 != error_code)
                throw SdkException(error_code);
            return headId;
        }

        //
        // Retrieves a copy of a the name of the head. The head name is currently
        // set only at the factory, and is simply "Head" on many sonars. Only special
        // order sonars with multiple heads are likely to have a different name.<br>
        // The length of the name has no actual limit, though 80 characters
        // would seem to be more than enough.
        //
        // @param buffer buffer to hold the null-terminated string to be passed back 
        // @param buffer_size total number of characters the passed buffer can hold         
        std::string GetHeadName()
        {
            char buffer[256] = { 0 };
            int buffer_size = 255;
            int error_code = BVTHead_GetHeadName(_owned.get(), buffer, buffer_size);
            if (0 != error_code)
                throw SdkException(error_code);
            return std::string(buffer);
        }

        //
        // Persistently sets the name of the head. This should not be done frequently due
        // wear on the sonar's onboard storage (Flash memory). The head name is currently
        // set at the factory, and is simply "Head" on many sonars. Only special
        // order sonars with multiple heads are likely to have a different name.
        //
        // @param name null-terminated name string.         
        void SetHeadName(const std::string & name)
        {
            int error_code = BVTHead_SetHeadName(_owned.get(), name.c_str());
            if (0 != error_code)
                throw SdkException(error_code);
        }

        //
        // Set the range to be acquired.
        // @note The start range must be greater than or equal to @ref GetMinimumRange, and the stop range must be less than or equal to @ref GetMaximumRange
        // \warning You may not call this during recording on either the source sonar or the destination file sonar.
        //
        // @param start Start range in meters. 
        // @param stop Stop range in meters.        
        void SetRange(float start, float stop)
        {
            int error_code = BVTHead_SetRange(_owned.get(), start, stop);
            if (0 != error_code)
                throw SdkException(error_code);
        }

        //
        // Retrieve the current starting range in meters
        //
        // @param start start range in meters       
        float GetStartRange()
        {
            float start;
            int error_code = BVTHead_GetStartRange(_owned.get(), /* out */ &start);
            if (0 != error_code)
                throw SdkException(error_code);
            return start;
        }

        //
        // Retrieve the current stopping range in meters.
        //
        // @param stop stop range in meters     
        float GetStopRange()
        {
            float stop;
            int error_code = BVTHead_GetStopRange(_owned.get(), /* out */ &stop);
            if (0 != error_code)
                throw SdkException(error_code);
            return stop;
        }

        //
        // Return the minimum allowable range for this head.
        //
        // @param range minimum range in meters     
        float GetMinimumRange()
        {
            float range;
            int error_code = BVTHead_GetMinimumRange(_owned.get(), /* out */ &range);
            if (0 != error_code)
                throw SdkException(error_code);
            return range;
        }

        //
        // Return the maximum allowable range for this head.
        //
        // @param range maximum range in meters     
        float GetMaximumRange()
        {
            float range;
            int error_code = BVTHead_GetMaximumRange(_owned.get(), /* out */ &range);
            if (0 != error_code)
                throw SdkException(error_code);
            return range;
        }

        //
        // Set the start range of this head in meters.
        // @note The start range must be greater than or equal to @ref GetMinimumRange.
        //
        // @param start Start range in meters       
        void SetStartRange(float start)
        {
            int error_code = BVTHead_SetStartRange(_owned.get(), start);
            if (0 != error_code)
                throw SdkException(error_code);
        }

        //
        // Set the stop range of this head in meters.
        // @note The stop range must be less than or equal to @ref GetMaximumRange
        //
        // @param stop Stop range in meters         
        void SetStopRange(float stop)
        {
            int error_code = BVTHead_SetStopRange(_owned.get(), stop);
            if (0 != error_code)
                throw SdkException(error_code);
        }

        //
        // SetClippingThreshold function will set the maximum (+-) raw data 
        // value from the ADC.  If this threshold is reached the entire signal 
        // is zeroed out so that clipping is not propagated through out the 
        // image.  The threshold is an integer ranging from 1 to 4096 (2^12).
        //
        // @param threshold The clipping threshold. Allowed values: 1 to 4096 (2^12)        
        void SetClippingThreshold(int threshold)
        {
            int error_code = BVTHead_SetClippingThreshold(_owned.get(), threshold);
            if (0 != error_code)
                throw SdkException(error_code);
        }

        //
        // [obsolete]
        // GetClippingThreshold returns the integer value of the clipping threshold 
        //
        // @param threshold the clipping threshold      
        int GetClippingThreshold()
        {
            int threshold;
            int error_code = BVTHead_GetClippingThreshold(_owned.get(), /* out */ &threshold);
            if (0 != error_code)
                throw SdkException(error_code);
            return threshold;
        }

        //
        // [obsolete]
        // The EnableClippingThreshold needs to be called   first before setting the 
        // clipping threshold.  A value of true  will enable the feature while a value
        // of false will disable it.
        //
        // @param enable True if the clipping threshold should be applied.      
        void EnableClippingThreshold(bool enable)
        {
            int error_code = BVTHead_EnableClippingThreshold(_owned.get(), (enable ? 1 : 0));
            if (0 != error_code)
                throw SdkException(error_code);
        }

        //
        // Return the type of water the head is in.  The returned value will correspond to 
        // one of the FLUIDTYPE_* constants.
        //
        // @param fluidType fluid type      
        int GetFluidType()
        {
            int fluidType;
            int error_code = BVTHead_GetFluidType(_owned.get(), /* out */ &fluidType);
            if (0 != error_code)
                throw SdkException(error_code);
            return fluidType;
        }

        //
        // Set the type of water the head is in
        //
        // @param fluid The fluid type (one of the FLUIDTYPE_* constants)       
        void SetFluidType(enum FluidType::Enum fluid)
        {
            int error_code = BVTHead_SetFluidType(_owned.get(), ((int) fluid));
            if (0 != error_code)
                throw SdkException(error_code);
        }

        //
        // Return the current speed of sound in water for this head in meters per second.
        // Note that the returned sound speed is not measured by the sonar, but simply reflects the value currently set.
        //
        // @param speed speed of sound      
        int GetSoundSpeed()
        {
            int speed;
            int error_code = BVTHead_GetSoundSpeed(_owned.get(), /* out */ &speed);
            if (0 != error_code)
                throw SdkException(error_code);
            return speed;
        }

        //
        // Set the current speed of sound in water for this head in meters per second.
        //
        // @param speed Sound speed in water, meters per second         
        void SetSoundSpeed(int speed)
        {
            int error_code = BVTHead_SetSoundSpeed(_owned.get(), speed);
            if (0 != error_code)
                throw SdkException(error_code);
        }

        //
        // Return the additional analog gain in dB
        //
        // @param gain analog gain      
        float GetGainAdjustment()
        {
            float gain;
            int error_code = BVTHead_GetGainAdjustment(_owned.get(), /* out */ &gain);
            if (0 != error_code)
                throw SdkException(error_code);
            return gain;
        }

        //
        // Set the additional analog gain. 
        //
        // @param gain Additional analog gain in dB         
        void SetGainAdjustment(float gain)
        {
            int error_code = BVTHead_SetGainAdjustment(_owned.get(), gain);
            if (0 != error_code)
                throw SdkException(error_code);
        }

        //
        // Return the time variable gain in dB/meter. Note that the parameter is per unit distance, not per unit time. This is a convenience to remove the dependence on the sound speed for clients.
        //
        // @param slope slope in dB/meter       
        float GetTVGSlope()
        {
            float slope;
            int error_code = BVTHead_GetTVGSlope(_owned.get(), /* out */ &slope);
            if (0 != error_code)
                throw SdkException(error_code);
            return slope;
        }

        //
        // Set the  time variable analog gain. Note that the parameter is per unit distance, not per unit time. This is a convenience to remove the dependence on the sound speed for clients.
        //
        // @param tvg Time variable gain in dB/meter        
        void SetTVGSlope(float tvg)
        {
            int error_code = BVTHead_SetTVGSlope(_owned.get(), tvg);
            if (0 != error_code)
                throw SdkException(error_code);
        }

        //
        // Return true if this Head has dynamic power management enabled.
        //
        // @param is_enabled True if this Head has dynamic power management enabled.        
        bool GetDynamicPowerManagement()
        {
            int is_enabled;
            int error_code = BVTHead_GetDynamicPowerManagement(_owned.get(), /* out */ &is_enabled);
            if (0 != error_code)
                throw SdkException(error_code);
            return is_enabled > 0;
        }

        //
        // Note: Most BlueView sonars don't support dynamic power managment.
        //
        // @param enable If true, enable dynamic power managment.       
        void SetDynamicPowerManagement(bool enable)
        {
            int error_code = BVTHead_SetDynamicPowerManagement(_owned.get(), (enable ? 1 : 0));
            if (0 != error_code)
                throw SdkException(error_code);
        }

        //
        // Latest-generation BlueView sonar support two modes of operation,
        // a standard and an alternate mode. The alternate mode provides improved imagery for
        // wide field-of-view sonar (greater than 45 degrees) at the cost of a slower max
        // ping rate, while dual mode maximizes ping rate but reduces image
        // quality. This call provides the user details about whether the alternate
        // ping mode is supported on the given sonar head.
        //
        // @param is_supported true (1) if supported, false (0) otherwise       
        bool SupportsAlternatePingMode()
        {
            int is_supported;
            int error_code = BVTHead_SupportsAlternatePingMode(_owned.get(), /* out */ &is_supported);
            if (0 != error_code)
                throw SdkException(error_code);
            return is_supported > 0;
        }

        //
        // Sets the ping mode on sonar head. It is only
        // valid for sonar heads that support alternate ping mode.
        // (see SupportsAlternatePingMode()).
        //
        // @param enabled True or false.        
        void SetAlternatePingModeEnabled(bool enabled)
        {
            int error_code = BVTHead_SetAlternatePingModeEnabled(_owned.get(), (enabled ? 1 : 0));
            if (0 != error_code)
                throw SdkException(error_code);
        }

        //
        // Obtains the ping mode for the given sonar head.
        // It is only valid for sonar heads that support alternate ping mode
        // selection (see SupportsAlternatePingModemd()).
        //
        // @param enabled True or false.        
        bool GetAlternatePingModeEnabled()
        {
            int enabled;
            int error_code = BVTHead_GetAlternatePingModeEnabled(_owned.get(), /* out */ &enabled);
            if (0 != error_code)
                throw SdkException(error_code);
            return enabled > 0;
        }

        //
        // Return the center frequency(in Hz) of this head.
        //
        // @param frequency center frequency        
        int GetCenterFreq()
        {
            int frequency;
            int error_code = BVTHead_GetCenterFreq(_owned.get(), /* out */ &frequency);
            if (0 != error_code)
                throw SdkException(error_code);
            return frequency;
        }

        //
        // Return the number of pings 'in' this head
        // A head attached to a file might have more than one ping recorded.  However, a networked sonar will only have a single ping.
        //
        // @param count ping count      
        int GetPingCount()
        {
            int count;
            int error_code = BVTHead_GetPingCount(_owned.get(), /* out */ &count);
            if (0 != error_code)
                throw SdkException(error_code);
            return count;
        }

        //
        // Retrieve a Ping from the Head
        // If ping_num is less than 0, return the next ping in the file. Otherwise, load the specified ping.  
        // If the Head is attached to a 'live' sonar (network), then GetPing always acquires a new ping.
        //
        // @param ping_num The ping number to return 
        // @param ping The returned Ping object     
        Ping GetPing(int ping_num)
        {
            BVTPing ping_ptr = NULL;
            int error_code = BVTHead_GetPing(_owned.get(), ping_num, & ping_ptr);
            if (0 != error_code)
                throw SdkException(error_code);
            return Ping(ping_ptr);
        }

        //
        // \note This Head must be attached to a 'file' sonar.
        // Retrieve a Ping's metadata from the Head, skipping its signal data.
        // \warning You cannot create imagery from the ping returned by this function.
        // \warning Do not store the returned ping to another file unless you intend to never create imagery.
        // If ping_num is less than 0, return the next ping in the file. Otherwise, load the specified ping.
        //
        // @param ping_num The ping number to return 
        // @param ping The returned Ping object     
        Ping GetPingMetadataOnly(int ping_num)
        {
            BVTPing ping_ptr = NULL;
            int error_code = BVTHead_GetPingMetadataOnly(_owned.get(), ping_num, & ping_ptr);
            if (0 != error_code)
                throw SdkException(error_code);
            return Ping(ping_ptr);
        }

        //
        // Retrieve a Ping from a networked Head.
        // The Head must be attached to a 'live' sonar (network) which supports multicast pings.
        //
        // @param ping_num The ping number to return, currently unused 
        // @param ping The returned Ping object     
        Ping GetPingMulticast(int ping_num)
        {
            BVTPing ping_ptr = NULL;
            int error_code = BVTHead_GetPingMulticast(_owned.get(), ping_num, & ping_ptr);
            if (0 != error_code)
                throw SdkException(error_code);
            return Ping(ping_ptr);
        }

        //
        // Retrieve a multicast Ping from a networked Head, but do not ask the Head to emit a ping.
        // The Head must be attached to a 'live' sonar (network) which supports multicast pings.
        // See also: Sonar_SupportsMulticast
        //
        // @param ping The returned Ping object         
        Ping ListenForPingMulticast()
        {
            BVTPing ping_ptr = NULL;
            int error_code = BVTHead_ListenForPingMulticast(_owned.get(), & ping_ptr);
            if (0 != error_code)
                throw SdkException(error_code);
            return Ping(ping_ptr);
        }

        //
        // Write a ping to a file.
        // \warning The source_ping's Head must match this Head.
        //
        // @param source_ping The ping to write out         
        void PutPing(const Ping & source_ping)
        {
            int error_code = BVTHead_PutPing(_owned.get(), source_ping.Handle());
            if (0 != error_code)
                throw SdkException(error_code);
        }

        //
        // Setting this to a non-zero number will cause a multicast ping to be emitted every N milliseconds.
        // This is only supported on sonar with newer firmware, and support can be checked with @ref BVTSonar_SupportsMulticast.
        //
        // @param milliseconds The number of milliseconds between each ping acquisition on the remote Head.         
        void SetPingInterval(int milliseconds)
        {
            int error_code = BVTHead_SetPingInterval(_owned.get(), milliseconds);
            if (0 != error_code)
                throw SdkException(error_code);
        }

        //
        // 
        //
        // @param milliseconds The number of milliseconds between each ping acquisition on the remote Head.         
        int GetPingInterval()
        {
            int milliseconds;
            int error_code = BVTHead_GetPingInterval(_owned.get(), /* out */ &milliseconds);
            if (0 != error_code)
                throw SdkException(error_code);
            return milliseconds;
        }

        //
        // Set the image processing resolution. The RES_AUTO setting is highly
        // recommended, as it adapts via a formula according to the stop range,
        // whereas the other ranges are fixed values, and should only be used
        // in specialized cases, such as requesting high resolution for longer
        // distances (which will increase the processing time required to 
        // create the image). R-Theta images may use either this function or
        // SetRangeResolution(), depending on the degree of control required.
        //
        // @param res Resolution constant (IMAGERES_*)      
        void SetImageRes(enum ImageRes::Enum res)
        {
            int error_code = BVTHead_SetImageRes(_owned.get(), ((int) res));
            if (0 != error_code)
                throw SdkException(error_code);
        }

        //
        // Requests a range resolution for R-Theta images. Also affects the
        // range resolution for RangeProfile. Note that the exact range resolution
        // may not be available, and the closest resolution will be set. The
        // actual resolution can be obtained by querying the returned image
        // or RangeProfile object.
        //
        // @param resolution_in_meters Range resolution, in meters      
        void SetRangeResolution(float resolution_in_meters)
        {
            int error_code = BVTHead_SetRangeResolution(_owned.get(), resolution_in_meters);
            if (0 != error_code)
                throw SdkException(error_code);
        }

        //
        // Set the requested out image size
        // The processing code will attempt to process images at the specified size.
        // However, it doesn't guarantee that the final output will match this size.
        // NOTE: For R-Theta images, only the width is used, and the image will
        // be created with that exact width. Height will depend on the range,
        // and the resolution set. (See SetImageRes() and SetRangeResolution())
        //
        // @param height The requested height 
        // @param width The requested width         
        void SetImageReqSize(int height, int width)
        {
            int error_code = BVTHead_SetImageReqSize(_owned.get(), height, width);
            if (0 != error_code)
                throw SdkException(error_code);
        }

        //
        // Return the XY dimensions
        //
        // @param height height in pixels 
        // @param width width in pixels         
        void GetXYImageSizeRequested(int *height, int *width)
        {
            int error_code = BVTHead_GetXYImageSizeRequested(_owned.get(), height, width);
            if (0 != error_code)
                throw SdkException(error_code);
        }

        //
        // Set the XY image size
        // This is a helper function to accompany the Ping's GetImageXY() function.
        //
        // @param width The requested width 
        // @param height The requested height       
        void SetXYImageSize(int width, int height)
        {
            int error_code = BVTHead_SetXYImageSize(_owned.get(), width, height);
            if (0 != error_code)
                throw SdkException(error_code);
        }

        //
        // Set the RTheta image width
        // This is a helper function to accompany the Ping's GetImageRTheta() function.
        //
        // @param width The requested width         
        void SetRThetaImageWidth(int width)
        {
            int error_code = BVTHead_SetRThetaImageWidth(_owned.get(), width);
            if (0 != error_code)
                throw SdkException(error_code);
        }

        //
        // Set the type of image created by the BVTPing_GetImage() function.
        // NOTE: See SetImageReqSize() for important issues regarding image size.
        // If images are requested with the BVTPing_GetXYImage() or 
        // BVTPing_GetRThetaImage(), then this function is not needed.
        //
        // @param type Image type constant (IMAGETYPE_*)        
        void SetImageType(enum ImageType::Enum type)
        {
            int error_code = BVTHead_SetImageType(_owned.get(), ((int) type));
            if (0 != error_code)
                throw SdkException(error_code);
        }

        //
        // Return the filter flags.  As of this version, if more than one flag is set, only the lowest-valued flag is used.
        //
        // @param flags The image filter flags in effect.       
        enum ImageFilterFlags::Enum GetImageFilterFlags()
        {
            int flags;
            int error_code = BVTHead_GetImageFilterFlags(_owned.get(), /* out */ &flags);
            if (0 != error_code)
                throw SdkException(error_code);
            return (enum ImageFilterFlags::Enum) flags;
        }

        //
        // Set the filter flags. As of this version, if more than one flag is set, only the lowest-valued flag is used.
        //
        // @param flags The image filter flags to set (bit field).      
        void SetImageFilterFlags(enum ImageFilterFlags::Enum flags)
        {
            int error_code = BVTHead_SetImageFilterFlags(_owned.get(), ((int) flags));
            if (0 != error_code)
                throw SdkException(error_code);
        }

        //
        // Inform the user about which type of image processing algorithm is being used.
        // The returned value will correspond to one of the IMAGE_PROCESSING_METHOD_* constants.
        //
        // @param method The image processing method used by this Head.         
        enum ImageProcessingMethod::Enum GetImageProcessingMethod()
        {
            int method;
            int error_code = BVTHead_GetImageProcessingMethod(_owned.get(), /* out */ &method);
            if (0 != error_code)
                throw SdkException(error_code);
            return (enum ImageProcessingMethod::Enum) method;
        }

        //
        // Return the current image calibration value A.
        //
        // @param cal_value_a Undocumented.         
        int GetImageCalibrationA()
        {
            int cal_value_a;
            int error_code = BVTHead_GetImageCalibrationA(_owned.get(), /* out */ &cal_value_a);
            if (0 != error_code)
                throw SdkException(error_code);
            return cal_value_a;
        }

        //
        // Set the image calibration value for A.
        // This function should only be used for older sonars.  Before using this function,
        // call @ref GetImageProcessingMethod and test the return value.  If the return
        // value is IMAGE_PROCESSING_METHOD_A (0), then this function may be used, otherwise, do not
        // use this function.
        // NOTE: These values will be permanently saved on the sonar,
        // and the sonar's FLASH memory has limited write cycles available,
        // so this function should not be called often.
        //
        // @param cal_value_a Undocumented.         
        void SetImageCalibrationA(int cal_value_a)
        {
            int error_code = BVTHead_SetImageCalibrationA(_owned.get(), cal_value_a);
            if (0 != error_code)
                throw SdkException(error_code);
        }

        //
        // Return the current image calibration value B.
        //
        // @param cal_value_b Undocumented.         
        int GetImageCalibrationB()
        {
            int cal_value_b;
            int error_code = BVTHead_GetImageCalibrationB(_owned.get(), /* out */ &cal_value_b);
            if (0 != error_code)
                throw SdkException(error_code);
            return cal_value_b;
        }

        //
        // Set the image calibration value for B.
        // This function should only be used for older sonars.  Before using this function,
        // call  @ref GetImageProcessingMethod() and test the return value.  If the return
        // value is IMAGE_PROCESSING_METHOD_A (0), then this function may be used, otherwise, do not
        // use this function.
        // NOTE: These values will be permanently saved on the sonar,
        // and the sonar's FLASH memory has limited write cycles available,
        // so this function should not be called often.
        //
        // @param cal_value_b Undocumented.         
        void SetImageCalibrationB(int cal_value_b)
        {
            int error_code = BVTHead_SetImageCalibrationB(_owned.get(), cal_value_b);
            if (0 != error_code)
                throw SdkException(error_code);
        }

        //
        // By default, the sonar transmits pings.  This function allows the user to 
        // disable transmit.  This can be useful to get background noise measurements.
        // Note that this is not implemented on all sonars.
        //
        // @param enableTx If 0, disable the sonar transmission of pings.       
        void SetTxEnable(int enableTx)
        {
            int error_code = BVTHead_SetTxEnable(_owned.get(), enableTx);
            if (0 != error_code)
                throw SdkException(error_code);
        }

        //
        // Stores a copy of the Orientation data with the in the head's MountingOrientation object, so the data
        // will be saved if the head is saved to a file.
        //
        // @param orient Orientation data object to copy from       
        void SetMountingOrientation(const Orientation & orient)
        {
            int error_code = BVTHead_SetMountingOrientation(_owned.get(), orient.Handle());
            if (0 != error_code)
                throw SdkException(error_code);
        }

        //
        // Retrieves a copy of the MountingOrientation object stored with this head. Note
        // that the data is copied out of the head into the local Orientation object,
        // a pointer to internal data is not returned. Thus, the Orientation object
        // may be used after the head is destroyed.
        //
        // @param orient Orientation data object to copy the existing Orientation data to       
        Orientation GetMountingOrientationCopy()
        {
            BVTOrientation orient_ptr = NULL;
            int error_code = BVTHead_GetMountingOrientationCopy(_owned.get(), & orient_ptr);
            if (0 != error_code)
                throw SdkException(error_code);
                        return Orientation(orient_ptr);
        }

        //
        // Stores a copy of the Orientation data with the in the head's MountingOrientation object, so the data
        // will be saved if the head is saved to a file.
        // This second (auxillary) Orientation object is optional. 
        //
        // @param orient Orientation data object to copy from       
        void SetAuxMountingOrientation(const Orientation & orient)
        {
            int error_code = BVTHead_SetAuxMountingOrientation(_owned.get(), orient.Handle());
            if (0 != error_code)
                throw SdkException(error_code);
        }

        //
        // Retrieves a copy of the MountingOrientation object stored with this head. Note
        // that the data is copied out of the head into the local Orientation object,
        // a pointer to internal data is not returned. Thus, the Orientation object
        // may be used after the head is destroyed.
        // This second (auxillary) Orientation object is optional.  Calling this function on an unused auxillary Orientation will return all zeros. 
        //
        // @param orient Orientation data object to copy the existing Orientation data to       
        Orientation GetAuxMountingOrientationCopy()
        {
            BVTOrientation orient_ptr = NULL;
            int error_code = BVTHead_GetAuxMountingOrientationCopy(_owned.get(), & orient_ptr);
            if (0 != error_code)
                throw SdkException(error_code);
                        return Orientation(orient_ptr);
        }

        //
        // Return the number of transducers for this head
        //
        // @param count number of trandsucers       
        int GetTransducerCount()
        {
            int count;
            int error_code = BVTHead_GetTransducerCount(_owned.get(), /* out */ &count);
            if (0 != error_code)
                throw SdkException(error_code);
            return count;
        }

        //
        // Get the transducer orientation for the specified transducer index.
        //
        // @param transducer_index The zero-based index of the transducer
        // @param orient The orientation of the transducer.         
        Orientation GetTransducerOrientationCopy(int transducer_index)
        {
            BVTOrientation orient_ptr = NULL;
            int error_code = BVTHead_GetTransducerOrientationCopy(_owned.get(), transducer_index, & orient_ptr);
            if (0 != error_code)
                throw SdkException(error_code);
                        return Orientation(orient_ptr);
        }

        //
        // Identifies the general configuration of how this data was collected.
        //
        // @param type One of the MOUNTTYPE_* constants         
        void SetMountType(enum MountType::Enum type)
        {
            int error_code = BVTHead_SetMountType(_owned.get(), ((int) type));
            if (0 != error_code)
                throw SdkException(error_code);
        }

        //
        // Returns the mount type.  The returned value will correspond to
        // one of the MOUNTTYPE_* constants.
        //
        // @param type mount type       
        enum MountType::Enum GetMountType()
        {
            int type;
            int error_code = BVTHead_GetMountType(_owned.get(), /* out */ &type);
            if (0 != error_code)
                throw SdkException(error_code);
            return (enum MountType::Enum) type;
        }

        //
        // Specifiy where the sonar was mounted when this data was collected.
        //
        // @param side One of the MOUNTSIDE_* constants         
        void SetMountSide(enum MountSide::Enum side)
        {
            int error_code = BVTHead_SetMountSide(_owned.get(), ((int) side));
            if (0 != error_code)
                throw SdkException(error_code);
        }

        //
        // Return where the sonar was mounted when this data was collected.
        // The returned value will correspond to one of the SIDE_* constants.
        //
        // @param side One of the MOUNTSIDE_* constants         
        enum MountSide::Enum GetMountSide()
        {
            int side;
            int error_code = BVTHead_GetMountSide(_owned.get(), /* out */ &side);
            if (0 != error_code)
                throw SdkException(error_code);
            return (enum MountSide::Enum) side;
        }

        //
        // This offset is calculated as MRU time - Sonar time;
        //
        // @param milliseconds Offset in milliseconds between the MRU's time reading and the Sonar's time reading.      
        void SetMRUTimeOffset(int milliseconds)
        {
            int error_code = BVTHead_SetMRUTimeOffset(_owned.get(), milliseconds);
            if (0 != error_code)
                throw SdkException(error_code);
        }

        //
        // This offset is calculated as MRU time - Sonar time;
        //
        // @param milliseconds Offset in milliseconds between the MRU's time reading and the Sonar's time reading.      
        int GetMRUTimeOffset()
        {
            int milliseconds;
            int error_code = BVTHead_GetMRUTimeOffset(_owned.get(), /* out */ &milliseconds);
            if (0 != error_code)
                throw SdkException(error_code);
            return milliseconds;
        }

        //
        // 
        //
        // @param bearing Bearing in degrees from pole mount to GPS antenna. 
        // @param distance Distance in meters from pole mount to GPS antenna.       
        void SetPoleGPSBearing(float bearing, float distance)
        {
            int error_code = BVTHead_SetPoleGPSBearing(_owned.get(), bearing, distance);
            if (0 != error_code)
                throw SdkException(error_code);
        }

        //
        // 
        //
        // @param bearing Bearing in degrees from pole mount to GPS antenna. 
        // @param distance Distance in meters from pole mount to GPS antenna.       
        void GetPoleGPSBearing(float *bearing, float *distance)
        {
            int error_code = BVTHead_GetPoleGPSBearing(_owned.get(), bearing, distance);
            if (0 != error_code)
                throw SdkException(error_code);
        }

        //
        // 
        //
        // @param bearing Bearing in degrees from pole mount to landmark.       
        void SetPoleLandmarkBearing(float bearing)
        {
            int error_code = BVTHead_SetPoleLandmarkBearing(_owned.get(), bearing);
            if (0 != error_code)
                throw SdkException(error_code);
        }

        //
        // Returns bearing in degrees from pole mount to landmark. 
        //      
        float GetPoleLandmarkBearing()
        {
            return BVTHead_GetPoleLandmarkBearing(_owned.get());
        }

        //
        // This is used in tripod mount situations where the default/baseline/normal/center
        // position of the Head is not aligned with the tripod-mounted compass's
        // North direction.
        // This offset is calculated as MRU time - Sonar time;          
        //
        // @param offset Offset in degrees from compass North.      
        void SetHeadingOffset(float offset)
        {
            int error_code = BVTHead_SetHeadingOffset(_owned.get(), offset);
            if (0 != error_code)
                throw SdkException(error_code);
        }

        //
        // Returns offset in degrees from compass North. 
        // This is used in tripod mount situations where the default/baseline/normal/center
        // position of the Head is not aligned with the tripod-mounted compass's
        // North direction.
        //
        // @param offset heading offset     
        float GetHeadingOffset()
        {
            float offset;
            int error_code = BVTHead_GetHeadingOffset(_owned.get(), /* out */ &offset);
            if (0 != error_code)
                throw SdkException(error_code);
            return offset;
        }

        //
        // This is used to compute x,y,z offsets driven by the tilt position.
        // The manufacturer and model strings are limited to a maximum of 79 characters, not counting the terminating null characters.
        //
        // @param manufacturer Manufacturer of pan/tilt unit e.g. ROS 
        // @param model pan/tilt model  
        // @param elbowOffset offset from tilt motor axis to center of sonar        
        void SetPanTiltAttributes(const std::string & manufacturer, const std::string & model, float elbowOffset)
        {
            int error_code = BVTHead_SetPanTiltAttributes(_owned.get(), manufacturer.c_str(), model.c_str(), elbowOffset);
            if (0 != error_code)
                throw SdkException(error_code);
        }

        //
        // Returns the name of the Pan-Tilt manufacturer as a string.
        //
        // @param manufacturer The buffer to hold the returned manufacturer name string. 
        // @param buffer_length The size in chararacters of the buffer to hold the returned manufacturer string.        
        std::string GetPanTiltManufacturer()
        {
            char manufacturer[256] = { 0 };
            int buffer_length = 255;
            int error_code = BVTHead_GetPanTiltManufacturer(_owned.get(), manufacturer, buffer_length);
            if (0 != error_code)
                throw SdkException(error_code);
            return std::string(manufacturer);
        }

        //
        // Returns the length of the name of the Pan-Tilt manufacturer as a string.
        //
        // @param buffer_length The size in characters of the manufacturer name string.         
        int GetPanTiltManufacturerLength()
        {
            int buffer_length;
            int error_code = BVTHead_GetPanTiltManufacturerLength(_owned.get(), /* out */ &buffer_length);
            if (0 != error_code)
                throw SdkException(error_code);
            return buffer_length;
        }

        //
        // Returns the model name.
        //
        // @param model The string to hold the returned model name. 
        // @param buffer_length The size in bytes of the buffer 'model'         
        std::string GetPanTiltModel()
        {
            char model[256] = { 0 };
            int buffer_length = 255;
            int error_code = BVTHead_GetPanTiltModel(_owned.get(), model, buffer_length);
            if (0 != error_code)
                throw SdkException(error_code);
            return std::string(model);
        }

        //
        // Returns the length of the model name.
        //
        // @param buffer_length The string length of the model name.        
        int GetPanTiltModelLength()
        {
            int buffer_length;
            int error_code = BVTHead_GetPanTiltModelLength(_owned.get(), /* out */ &buffer_length);
            if (0 != error_code)
                throw SdkException(error_code);
            return buffer_length;
        }

        //
        // This is used to compute x,y,z offsets driven by the tilt position. Elbow offset specified in meters
        //
        // @param offset offset to P/T elbow        
        float GetPanTiltElbowOffset()
        {
            float offset;
            int error_code = BVTHead_GetPanTiltElbowOffset(_owned.get(), /* out */ &offset);
            if (0 != error_code)
                throw SdkException(error_code);
            return offset;
        }

        //
        // Helper function to retrieve the pan/tilt mount offsets.  
        // The panRotationOffset and tiltRotationOffset values should be subtracted 
        // from the X_axis_degrees (pan) and Y_axis_degrees (tilt) parameters 
        // of the BVTPing_GetPositionerRotations() function to obtain 
        // the same pan & tilt values displayed during data collection.
        // If verticalInverted is false(0), then the tilt value obtained in the 
        // step above must be multiplied by -1.0 to represent real-world tilt values.
        //
        // @param tiltElbowVerticalOffset in meters 
        // @param tiltElbowHorizontalOffset in meters 
        // @param panRotationOffset offset to "home" position 
        // @param tiltRotationOffset offset to "home" position 
        // @param verticalInverted either 1 or 0, to indicate true or false, respectively       
        void GetPanTiltMountOffsets(float *tiltElbowVerticalOffset, float *tiltElbowHorizontalOffset, float *panRotationOffset, float *tiltRotationOffset, int *verticalInverted)
        {
            int error_code = BVTHead_GetPanTiltMountOffsets(_owned.get(), tiltElbowVerticalOffset, tiltElbowHorizontalOffset, panRotationOffset, tiltRotationOffset, verticalInverted);
            if (0 != error_code)
                throw SdkException(error_code);
        }

        //
        // Helper function to set the pan/tilt mount offsets.  
        // The panRotationOffset and tiltRotationOffset values should be subtracted 
        // from the X_axis_degrees (pan) and Y_axis_degrees (tilt) parameters 
        // of the BVTPing_GetPositionerRotations() function to obtain 
        // the same pan & tilt values displayed during data collection.
        // verticalInverted is set to false(0) if the pan/tilt device has been mounted in an inverted fashion.
        //
        // @param tiltElbowVerticalOffset in meters 
        // @param tiltElbowHorizontalOffset in meters 
        // @param panRotationOffset offset to "home" position 
        // @param tiltRotationOffset offset to "home" position 
        // @param verticalInverted either 1 or 0, to indicate true or false, respectively       
        void SetPanTiltMountOffsets(float tiltElbowVerticalOffset, float tiltElbowHorizontalOffset, float panRotationOffset, float tiltRotationOffset, int verticalInverted)
        {
            int error_code = BVTHead_SetPanTiltMountOffsets(_owned.get(), tiltElbowVerticalOffset, tiltElbowHorizontalOffset, panRotationOffset, tiltRotationOffset, verticalInverted);
            if (0 != error_code)
                throw SdkException(error_code);
        }

    };

}

#endif
