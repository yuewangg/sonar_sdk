/*
    This file has been generated by bvtidl.pl. DO NOT MODIFY!
*/

#ifndef __CPP_BVTIMAGEGENERATOR_HPP__
#define __CPP_BVTIMAGEGENERATOR_HPP__

#include "bvt_imageres.hpp"
#include "bvt_imagefilterflags.hpp"
#include <string>
#ifdef _WIN32
#   include <memory>
#else
#   include <cstddef>
#   if defined (__GLIBCXX__) && __cplusplus <= 199711L
#      include <tr1/memory>
       namespace std {
          using std::tr1::shared_ptr;
       }
#   else
#       include <memory>
#   endif
#endif
#include <bvt_cpp/bvt_retval.hpp>
#include <bvt_cpp/bvt_error.hpp>
#include <bvt_cpp/bvt_head.hpp>
#include <bvt_cpp/bvt_magimage.hpp>
#include <bvt_cpp/bvt_ping.hpp>
#include <bvt_cpp/bvt_rangeprofile.hpp>

namespace BVTSDK
{

    class MagImage;
    class Ping;
    class Head;
    class RangeProfile;

    /// <summary>
    /// An ImageGenerator processes Ping data to create images.  
    /// Thread-safety: none.
    /// <summary>
    class ImageGenerator
    {
    public:
        ImageGenerator()
        {
            BVTImageGenerator p = BVTImageGenerator_Create();
            _owned = std::shared_ptr<BVTOpaqueImageGenerator>(p , BVTImageGenerator_Destroy );
        }
    public: /*consider private*/
        ImageGenerator(BVTImageGenerator p)
        {
            _owned = std::shared_ptr<BVTOpaqueImageGenerator>(p , BVTImageGenerator_Destroy );
        }
    public:
        ~ImageGenerator()
        {
            
        }

    //public:
    //  ImageGenerator(const ImageGenerator &) {}
    //  ImageGenerator& operator=(const ImageGenerator &) {}
    public:
        /// SDK object pointer
        BVTImageGenerator Handle() const
        {
            return _owned.get();
        }
    private:
        std::shared_ptr<BVTOpaqueImageGenerator> _owned;

    public:
        static const int SOUND_SPEED_OVERRIDE_OFF = 0;

        //
        // Set the Head and perform expensive initialization.
        // @see IsValidForHead
        //
        // @param head The Head from which subsequent pings will be passed      
        void SetHead(const Head & head)
        {
            int error_code = BVTImageGenerator_SetHead(_owned.get(), head.Handle());
            if (0 != error_code)
                throw SdkException(error_code);
        }

        //
        // Return true if the specified Head is associated with this instance. If false, you must
        // call SetHead.
        // @see SetHead
        //
        // @param head The Head to check 
        // @param is_valid True if the specified Head is valid for this instance.       
        bool IsValidForHead(const Head & head)
        {
            int is_valid;
            int error_code = BVTImageGenerator_IsValidForHead(_owned.get(), head.Handle(), /* out */ &is_valid);
            if (0 != error_code)
                throw SdkException(error_code);
            return is_valid > 0;
        }

        //
        // Set the image processing resolution. The RES_AUTO setting is highly
        // recommended, as it adapts via a formula according to the stop range,
        // whereas the other ranges are fixed values, and should only be used
        // in specialized cases, such as requesting high resolution for longer
        // distances (which will increase the processing time required to 
        // create the image). R-Theta images may use either this function or
        // SetRangeResolution(), depending on the degree of control required.
        //
        // @param resolutionPolicy Resolution constant (IMAGERES_*)     
        void SetImageResolutionPolicy(enum ImageRes::Enum resolutionPolicy)
        {
            int error_code = BVTImageGenerator_SetImageResolutionPolicy(_owned.get(), ((int) resolutionPolicy));
            if (0 != error_code)
                throw SdkException(error_code);
        }

        //
        // Return the algorithm used to calculate image resolution.
        //
        // @param resolutionPolicy Resolution constant (IMAGERES_*)         
        enum ImageRes::Enum GetImageResolutionPolicy()
        {
            int resolutionPolicy;
            int error_code = BVTImageGenerator_GetImageResolutionPolicy(_owned.get(), /* out */ &resolutionPolicy);
            if (0 != error_code)
                throw SdkException(error_code);
            return (enum ImageRes::Enum) resolutionPolicy;
        }

        //
        // Return the filter flags.  As of this version, if more than one flag is set, only the lowest-valued flag is used.
        //
        // @param flags The image filter flags in use. (Bit field)      
        enum ImageFilterFlags::Enum GetImageFilterFlags()
        {
            int flags;
            int error_code = BVTImageGenerator_GetImageFilterFlags(_owned.get(), /* out */ &flags);
            if (0 != error_code)
                throw SdkException(error_code);
            return (enum ImageFilterFlags::Enum) flags;
        }

        //
        // Set the filter flags. As of this version, if more than one flag is set, only the lowest-valued flag is used.
        //
        // @param flags Image filter flags to use (bit field)       
        void SetImageFilterFlags(enum ImageFilterFlags::Enum flags)
        {
            int error_code = BVTImageGenerator_SetImageFilterFlags(_owned.get(), ((int) flags));
            if (0 != error_code)
                throw SdkException(error_code);
        }

        //
        // @see SetRangeResolution
        //
        // @param resolution_in_meters Range resolution, in meters      
        float GetRangeResolution()
        {
            float resolution_in_meters;
            int error_code = BVTImageGenerator_GetRangeResolution(_owned.get(), /* out */ &resolution_in_meters);
            if (0 != error_code)
                throw SdkException(error_code);
            return resolution_in_meters;
        }

        //
        // Requests a range resolution for R-Theta images. Also affects the
        // range resolution for RangeProfile. Note that the exact range resolution
        // may not be available, and the closest resolution will be set. The
        // actual resolution can be obtained by querying the returned image
        // or RangeProfile object.
        //
        // @param resolution_in_meters Range resolution, in meters      
        void SetRangeResolution(float resolution_in_meters)
        {
            int error_code = BVTImageGenerator_SetRangeResolution(_owned.get(), resolution_in_meters);
            if (0 != error_code)
                throw SdkException(error_code);
        }

        //
        // @see BVTHead_SetRangeProfileThreshold
        //
        // @param threshold minimum detection threshold         
        unsigned short GetRangeProfileIntensityThreshold()
        {
            unsigned short threshold;
            int error_code = BVTImageGenerator_GetRangeProfileIntensityThreshold(_owned.get(), /* out */ &threshold);
            if (0 != error_code)
                throw SdkException(error_code);
            return threshold;
        }

        //
        // @see BVTHead_SetRangeProfileThreshold
        //
        // @param threshold minimum detection threshold         
        void SetRangeProfileIntensityThreshold(unsigned short threshold)
        {
            int error_code = BVTImageGenerator_SetRangeProfileIntensityThreshold(_owned.get(), threshold);
            if (0 != error_code)
                throw SdkException(error_code);
        }

        //
        // @see BVTHead_SetTargetStartRange
        //
        // @param start_range minimum range to detect       
        float GetRangeProfileStartRange()
        {
            float start_range;
            int error_code = BVTImageGenerator_GetRangeProfileStartRange(_owned.get(), /* out */ &start_range);
            if (0 != error_code)
                throw SdkException(error_code);
            return start_range;
        }

        //
        // @see BVTHead_SetTargetStartRange
        //
        // @param start_range minimum detection to detect       
        void SetRangeProfileStartRange(float start_range)
        {
            int error_code = BVTImageGenerator_SetRangeProfileStartRange(_owned.get(), start_range);
            if (0 != error_code)
                throw SdkException(error_code);
        }

        //
        // Set the preferred XY image size. Note that the aspect ratio of the image
        // remains fixed (as a function of start and stop range). If you specify non-zero 
        // parameters to this method that violate the aspect ratio, the image width will be 
        // adjusted.
        // This is a helper function to accompany the GetImageXY() function.
        //
        // @param width The requested width, or 0 for no change 
        // @param height The requested height, or 0 for no change       
        void SetXYImageSize(int width, int height)
        {
            int error_code = BVTImageGenerator_SetXYImageSize(_owned.get(), width, height);
            if (0 != error_code)
                throw SdkException(error_code);
        }

        //
        // Set the RTheta image width
        // This is a helper function to accompany the GetImageRTheta() function.
        //
        // @param width The requested width         
        void SetRThetaImageWidth(int width)
        {
            int error_code = BVTImageGenerator_SetRThetaImageWidth(_owned.get(), width);
            if (0 != error_code)
                throw SdkException(error_code);
        }

        //
        // Get the RTheta image width
        // This is a helper function to accompany the GetImageRTheta() function.
        //
        // @param width The requested width         
        int GetRThetaImageWidth()
        {
            int width;
            int error_code = BVTImageGenerator_GetRThetaImageWidth(_owned.get(), /* out */ &width);
            if (0 != error_code)
                throw SdkException(error_code);
            return width;
        }

        //
        // Retrieve an XY-format image of this ping, according to the parameters set
        // in the head used to get this ping. Use BVTHead_SetImageSizeXY() to set the size for this image.
        // See Head and MagImage documentation for more details.
        //
        // @param ping The Ping to generate image from. 
        // @param img Output XY image       
        MagImage GetImageXY(const Ping & ping)
        {
            BVTMagImage img_ptr = NULL;
            int error_code = BVTImageGenerator_GetImageXY(_owned.get(), ping.Handle(), & img_ptr);
            if (0 != error_code)
                throw SdkException(error_code);
                        return MagImage(img_ptr);
        }

        //
        // Retrieve an R-Theta format image of this ping, according to the parameters set
        // in the head used to get this ping. Use BVTHead_SetImageWidthRTheta() to set the size for this image.
        // See Head and MagImage documentation for more details.
        //
        // @param ping The Ping to generate image from. 
        // @param img Output R-Theta image      
        MagImage GetImageRTheta(const Ping & ping)
        {
            BVTMagImage img_ptr = NULL;
            int error_code = BVTImageGenerator_GetImageRTheta(_owned.get(), ping.Handle(), & img_ptr);
            if (0 != error_code)
                throw SdkException(error_code);
                        return MagImage(img_ptr);
        }

        //
        // Creates and returns RangeProfile for the ping.
        // @warning This function will fail on a sonar with old firmware, or a file recorded from a sonar with old firmware.
        //
        // @param ping The Ping to generate image from. 
        // @param ranges The created RangeProfile       
        RangeProfile GetRangeProfile(const Ping & ping)
        {
            BVTRangeProfile ranges_ptr = NULL;
            int error_code = BVTImageGenerator_GetRangeProfile(_owned.get(), ping.Handle(), & ranges_ptr);
            if (0 != error_code)
                throw SdkException(error_code);
                        return RangeProfile(ranges_ptr);
        }

        //
        // Returns the RangeProfile for a ping with RangeProfile created on the sonar, not the client.
        // @note Returns an error if this ping does not have a stored RangeProfile.
        //
        // @param ping The Ping to generate image from. 
        // @param ranges The created RangeProfile       
        RangeProfile GetStoredRangeProfile(const Ping & ping)
        {
            BVTRangeProfile ranges_ptr = NULL;
            int error_code = BVTImageGenerator_GetStoredRangeProfile(_owned.get(), ping.Handle(), & ranges_ptr);
            if (0 != error_code)
                throw SdkException(error_code);
                        return RangeProfile(ranges_ptr);
        }

        //
        // The clipping threshold specifies the percentage of dynamic range above which data will be nulled. 
        // The value must be set between 0.0 and 1.0. A value of 0.0 indicates 
        // that all data should be nulled (everything clips), while a value of 1.0 effectively 
        // disables any high-side thresholding. Clipped data is not processed, saving CPU cycles, 
        // so the clipping threshold may serve as a performance tuning parameter.
        //
        // @param threshold The upper bound threshold as a percentage of dynamic range for valid data from the A/D      
        void SetClippingThreshold(float threshold)
        {
            int error_code = BVTImageGenerator_SetClippingThreshold(_owned.get(), threshold);
            if (0 != error_code)
                throw SdkException(error_code);
        }

        //
        // Returns the floating point value of the clipping threshold. 
        // This threshold represents a percentage of dynamic range above which data is considered 
        // clipped and subsequently nulled. 
        //
        // @param threshold Lower bound threshold value from 0 to 1         
        float GetClippingThreshold()
        {
            float threshold;
            int error_code = BVTImageGenerator_GetClippingThreshold(_owned.get(), /* out */ &threshold);
            if (0 != error_code)
                throw SdkException(error_code);
            return threshold;
        }

        //
        // The noise threshold specifies the percentage of dynamic range below which data will be nulled. 
        // The value must be set between 0.0 and 1.0. A value of 0.0 indicates that no data should be nulled, 
        // effectively disabling low-side thresholding, while a value of 1.0 will force all data to be nulled. 
        // Data that is not above the noise threshold is not processed, saving CPU cycles, so the noise 
        // threshold may serve as a performance tuning parameter.
        //
        // @param threshold The lower bound threshold as a percentage of dynamic range for valid data from the A/D      
        void SetNoiseThreshold(float threshold)
        {
            int error_code = BVTImageGenerator_SetNoiseThreshold(_owned.get(), threshold);
            if (0 != error_code)
                throw SdkException(error_code);
        }

        //
        // Returns the floating point value of the noise threshold. This threshold 
        // represents a percentage of dynamic range below which data is considered 
        // to be noise and subsequently nulled.
        //
        // @param threshold The noise threshold in use.         
        float GetNoiseThreshold()
        {
            float threshold;
            int error_code = BVTImageGenerator_GetNoiseThreshold(_owned.get(), /* out */ &threshold);
            if (0 != error_code)
                throw SdkException(error_code);
            return threshold;
        }

        //
        // When the GetImage functions are called, ignore the sound speed stored in the ping and 
        // use this value instead.  
        // Use the default SOUND_SPEED_OVERRIDE_OFF to use the ping's stored sound speed.  
        //
        // @param meters_per_second The sound speed in meters per second        
        void SetSoundSpeedOverride(int meters_per_second)
        {
            int error_code = BVTImageGenerator_SetSoundSpeedOverride(_owned.get(), meters_per_second);
            if (0 != error_code)
                throw SdkException(error_code);
        }

        //
        // 
        //
        // @param meters_per_second The sound speed in meters per second        
        int GetSoundSpeedOverride()
        {
            int meters_per_second;
            int error_code = BVTImageGenerator_GetSoundSpeedOverride(_owned.get(), /* out */ &meters_per_second);
            if (0 != error_code)
                throw SdkException(error_code);
            return meters_per_second;
        }

        //
        // Do not use this. Experimental.
        //
        // @param algorithm Undocumented.       
        void SetMapAlgorithm(int algorithm)
        {
            int error_code = BVTImageGenerator_SetMapAlgorithm(_owned.get(), algorithm);
            if (0 != error_code)
                throw SdkException(error_code);
        }

        //
        // Do not use this. Experimental.
        //
        // @param algorithm Undocumented.       
        int GetMapAlgorithm()
        {
            int algorithm;
            int error_code = BVTImageGenerator_GetMapAlgorithm(_owned.get(), /* out */ &algorithm);
            if (0 != error_code)
                throw SdkException(error_code);
            return algorithm;
        }

        //
        // @warning This function will fail on a sonar with old firmware, or a file recorded from a sonar with old firmware.
        //
        // @param ping The ping to modify.      
        void CreateStoredRangeProfileAndReplaceSignal(Ping & ping)
        {
            int error_code = BVTImageGenerator_CreateStoredRangeProfileAndReplaceSignal(_owned.get(), ping.Handle());
            if (0 != error_code)
                throw SdkException(error_code);
        }

        //
        // Retrieve the current overlap blending parameters.
        //
        // @param nearRangeBeamToFavor Beam to favor at the sonar min range. 0 is highest freq., 128 is lowest freq. 
        // @param farRangeBeamToFavor Beam to favor at the sonar max range. 
        // @param rangeSkewExponent Controls the rate of change between nearRangeBeamToFavor and farRangeBeamToFavor w.r.t. pixel range, 0<e<1 ==> Move to far range beams quickly, 1<e<inf ==> Move to far range beams slowly 
        // @param beamWeightExponent Controls relative weights of beams close to and far from the beam to favor. e=0 ==> All beams weighted equally. As e increases, proximity to beam to favor becomes a greater factor in weighting       
        void GetSectorOverlapBlendingParams(unsigned int *nearRangeBeamToFavor, unsigned int *farRangeBeamToFavor, float *rangeSkewExponent, float *beamWeightExponent)
        {
            int error_code = BVTImageGenerator_GetSectorOverlapBlendingParams(_owned.get(), nearRangeBeamToFavor, farRangeBeamToFavor, rangeSkewExponent, beamWeightExponent);
            if (0 != error_code)
                throw SdkException(error_code);
        }

        //
        // Set the overlap blending parameters. 
        //
        // @param nearRangeBeamToFavor Beam to favor at the sonar min range. 0 is highest freq., 128 is lowest freq. 
        // @param farRangeBeamToFavor Beam to favor at the sonar max range. 
        // @param rangeSkewExponent Controls the rate of change between nearRangeBeamToFavor and farRangeBeamToFavor w.r.t.pixel range, 0<e<1 == > Move to far range beams quickly, 1<e<inf == > Move to far range beams slowly 
        // @param beamWeightExponent Controls relative weights of beams close to and far from the beam to favor.e = 0 == > All beams weighted equally.As e increases, proximity to beam to favor becomes a greater factor in weighting      
        void SetSectorOverlapBlendingParams(unsigned int nearRangeBeamToFavor, unsigned int farRangeBeamToFavor, float rangeSkewExponent, float beamWeightExponent)
        {
            int error_code = BVTImageGenerator_SetSectorOverlapBlendingParams(_owned.get(), nearRangeBeamToFavor, farRangeBeamToFavor, rangeSkewExponent, beamWeightExponent);
            if (0 != error_code)
                throw SdkException(error_code);
        }

    };

}

#endif
