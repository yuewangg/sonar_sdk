"""
This file was generated by bvtidl.pl.
Your changes will most likely be lost.
"""

from ctypes import *
import sys
import sdkerror


class NavData(object):
    """
    NavData contains various types of user-accessible navigation parameter, which
    can be saved to and retrieved from a sonar file on a per ping basis.
    The NavData objects can be created and destroyed as needed. When the
    ping functions are called to get or put the data, the data is copied.
    This allows NavData objects to be pre-allocated and filled from various
    instrument sources. It also allows the data to be copied from one
    NavData object to the other.
    NOTE: NavData changes will only be saved to a sonar of type FILE. 
    """
    def __init__(self, handle=None):
        super(NavData, self).__setattr__("_initialized", False)
        self._deleted = False
        if handle is None:
            self._handle = dll.BVTNavData_Create()
        else:
            self._handle = handle
        super(NavData, self).__setattr__("_initialized", True)

    def __del__(self):
        self._deleted = True
        dll.BVTNavData_Destroy(self._handle)

    def __setattr__(self, name, value):
        """ Don't allow setting non-existent attributes on this class
        """
        if self._initialized and not hasattr(self, name):
            raise AttributeError("%s instance has no attribute '%s'" % (self.__class__.__name__, name))
        super(NavData, self).__setattr__(name, value)

    def clone(self, navdata_to_clone):
        """
        Clones the data from the passed NavData object to this object. Both objects
        must have already been created.
        """
        error_code = dll.BVTNavData_Clone(self._handle, navdata_to_clone._handle)
        if (0 != error_code):
            raise sdkerror.SDKError(error_code)

    def clone_from(self, navdata_to_clone):
        """
        Clones the data from the passed NavData object to this object. Both objects
        must have already been created.
        """
        error_code = dll.BVTNavData_CloneFrom(self._handle, navdata_to_clone._handle)
        if (0 != error_code):
            raise sdkerror.SDKError(error_code)

    def clear(self):
        """
        Clears all fields in the NavData object so that the object may
        be reused. Following a call to this method, IsEmpty() returns
        true.
        """
        error_code = dll.BVTNavData_Clear(self._handle)
        if (0 != error_code):
            raise sdkerror.SDKError(error_code)

    @property
    def is_empty(self):
        """
        Returns true(1) if the NavData object contains no valid data.
        """
        empty = c_int()
        error_code = dll.BVTNavData_IsEmpty(self._handle, byref(empty))
        if (0 != error_code):
            raise sdkerror.SDKError(error_code)
        return empty.value > 0

    def merge(self, other):
        """
        Combines the fields of two NavData objects according to the following rules:
        1) If a field is populated in one object and empty in the other, the value from the populated object is kept
        2) If a field is full in both objects, the value with the more
        recent timestamp is kept
        3) If a field is empty in both objects, it remains empty
        """
        error_code = dll.BVTNavData_Merge(self._handle, other._handle)
        if (0 != error_code):
            raise sdkerror.SDKError(error_code)

    def clear_stale_fields(self, timestamp):
        """
        Clears all fields whose time of receipt is older than the value specified by timestamp (as provided by the system clock). Returns the number of valid fields left.
        """
        remainingFieldCount = c_int()
        error_code = dll.BVTNavData_ClearStaleFields(self._handle, timestamp, byref(remainingFieldCount))
        if (0 != error_code):
            raise sdkerror.SDKError(error_code)
        return remainingFieldCount.value

    def get_timespan(self, start, stop):
        """
        A single NavData object may contain data that was acquired over some length of time. This
        function allows the user to determine what that length is.
        """
        error_code = dll.BVTNavData_GetTimespan(self._handle, byref(start), byref(stop))
        if (0 != error_code):
            raise sdkerror.SDKError(error_code)

    @property
    def latitude(self):
        """
        Returns the latitude. If no latitude was stored, returns BVT_NAV_NO_DATA.
        """
        degrees = c_double()
        error_code = dll.BVTNavData_GetLatitude(self._handle, byref(degrees))
        if (0 != error_code):
            raise sdkerror.SDKError(error_code)
        return degrees.value

    def try_get_latitude(self, default_value):
        """
        Returns the latitude. If no latitude was stored, returns BVT_NAV_NO_DATA.
        """
        degrees = c_double()
        error_code = dll.BVTNavData_GetLatitude(self._handle, byref(degrees))
        if (0 != error_code):
            return default_value
        return degrees.value

    @property
    def latitude_timestamp(self):
        """
        Returns the Unix epoch time at which the field was set, including fractional seconds. 
        If no data was stored, the returns zero.
        NOTE: Timestamps are generated based on the value of the system clock at the time the
        field was set. As such, they are subject to substantial error due to clock drift and
        system latency and are in no way synchronized to any global standard. If such synchronization
        is required, please use the NavTime field and consider using a PPS signal.
        """
        timestamp = c_double()
        error_code = dll.BVTNavData_GetLatitudeTimestamp(self._handle, byref(timestamp))
        if (0 != error_code):
            raise sdkerror.SDKError(error_code)
        return timestamp.value

    @latitude.setter
    def latitude(self, degrees):
        """
        Stores the latitude, as a signed floating point number of degrees.
        Latitudes in the Southern hemisphere are expressed as negative numbers.
        """
        error_code = dll.BVTNavData_SetLatitude(self._handle, degrees)
        if (0 != error_code):
            raise sdkerror.SDKError(error_code)

    @property
    def longitude(self):
        """
        Returns the longitude. If no longitude was stored, returns BVT_NAV_NO_DATA.
        """
        degrees = c_double()
        error_code = dll.BVTNavData_GetLongitude(self._handle, byref(degrees))
        if (0 != error_code):
            raise sdkerror.SDKError(error_code)
        return degrees.value

    def try_get_longitude(self, default_value):
        """
        Returns the longitude. If no longitude was stored, returns BVT_NAV_NO_DATA.
        """
        degrees = c_double()
        error_code = dll.BVTNavData_GetLongitude(self._handle, byref(degrees))
        if (0 != error_code):
            return default_value
        return degrees.value

    @property
    def longitude_timestamp(self):
        """
        Returns the Unix epoch time at which the field was set, including fractional seconds. 
        If no data was stored, the returns zero.
        NOTE: Timestamps are generated based on the value of the system clock at the time the
        field was set. As such, they are subject to substantial error due to clock drift and
        system latency and are in no way synchronized to any global standard. If such synchronization
        is required, please use the NavTime field and consider using a PPS signal.
        """
        timestamp = c_double()
        error_code = dll.BVTNavData_GetLongitudeTimestamp(self._handle, byref(timestamp))
        if (0 != error_code):
            raise sdkerror.SDKError(error_code)
        return timestamp.value

    @longitude.setter
    def longitude(self, degrees):
        """
        Stores the longitude, as a signed floating point number of degrees.
        Longitudes in the Western hemisphere are expressed as negative numbers.
        """
        error_code = dll.BVTNavData_SetLongitude(self._handle, degrees)
        if (0 != error_code):
            raise sdkerror.SDKError(error_code)

    @property
    def horizontal_precision_error(self):
        """
        Returns the estimated horizontal error (see next function for details). 
        If none was stored, returns BVT_NAV_NO_DATA.
        """
        error_meters = c_float()
        error_code = dll.BVTNavData_GetHorizontalPrecisionError(self._handle, byref(error_meters))
        if (0 != error_code):
            raise sdkerror.SDKError(error_code)
        return error_meters.value

    def try_get_horizontal_precision_error(self, default_value):
        """
        Returns the estimated horizontal error (see next function for details). 
        If none was stored, returns BVT_NAV_NO_DATA.
        """
        error_meters = c_float()
        error_code = dll.BVTNavData_GetHorizontalPrecisionError(self._handle, byref(error_meters))
        if (0 != error_code):
            return default_value
        return error_meters.value

    @property
    def horizontal_precision_error_timestamp(self):
        """
        )
        Returns the Unix epoch time at which the field was set, including fractional seconds. 
        If no data was stored, the returns zero.
        NOTE: Timestamps are generated based on the value of the system clock at the time the
        field was set. As such, they are subject to substantial error due to clock drift and
        system latency and are in no way synchronized to any global standard. If such synchronization
        is required, please use the NavTime field and consider using a PPS signal.
        """
        timestamp = c_double()
        error_code = dll.BVTNavData_GetHorizontalPrecisionErrorTimestamp(self._handle, byref(timestamp))
        if (0 != error_code):
            raise sdkerror.SDKError(error_code)
        return timestamp.value

    @horizontal_precision_error.setter
    def horizontal_precision_error(self, error_meters):
        """
        Stores the estimated possible horizontal error. This is primarily (but not exclusively)
        intended for GPS systems, where there may be some doubt as to the
        quality of the position fix. HDOP is common, but not used here, as
        that is a unitless measure and varies between different manufacturers and models. <br>
        The idea is to use whatever calculations are appropriate for the 
        local navigation system, and store a possible error value in meters.
        Some GPS units will attempt to give this directly. (for example,
        the HPE field in the PGRME sentence, supplied by some Garmin units.)
        In the case of large errors, or old data, it may be best to either
        not store a position, or not store new data. (also consider using
        the NavData time parameter to store the time of last fix, which
        can then be compared to the ping time when the data is read back to
        determine the age of the GPS reading.)
        """
        error_code = dll.BVTNavData_SetHorizontalPrecisionError(self._handle, error_meters)
        if (0 != error_code):
            raise sdkerror.SDKError(error_code)

    @property
    def height(self):
        """
        Returns the height above Mean Sea Level. If no value was stored for
        this ping, returns BVT_NAV_NO_DATA.
        """
        meters_above_geoid = c_float()
        error_code = dll.BVTNavData_GetHeight(self._handle, byref(meters_above_geoid))
        if (0 != error_code):
            raise sdkerror.SDKError(error_code)
        return meters_above_geoid.value

    def try_get_height(self, default_value):
        """
        Returns the height above Mean Sea Level. If no value was stored for
        this ping, returns BVT_NAV_NO_DATA.
        """
        meters_above_geoid = c_float()
        error_code = dll.BVTNavData_GetHeight(self._handle, byref(meters_above_geoid))
        if (0 != error_code):
            return default_value
        return meters_above_geoid.value

    @property
    def height_timestamp(self):
        """
        Returns the Unix epoch time at which the field was set, including fractional seconds. 
        If no data was stored, the returns zero.
        NOTE: Timestamps are generated based on the value of the system clock at the time the
        field was set. As such, they are subject to substantial error due to clock drift and
        system latency and are in no way synchronized to any global standard. If such synchronization
        is required, please use the NavTime field and consider using a PPS signal.
        """
        timestamp = c_double()
        error_code = dll.BVTNavData_GetHeightTimestamp(self._handle, byref(timestamp))
        if (0 != error_code):
            raise sdkerror.SDKError(error_code)
        return timestamp.value

    @height.setter
    def height(self, meters_above_geoid):
        """
        Store the height above Mean Sea Level (usually the EGM96 geoid)
        """
        error_code = dll.BVTNavData_SetHeight(self._handle, meters_above_geoid)
        if (0 != error_code):
            raise sdkerror.SDKError(error_code)

    @property
    def vertical_precision_error(self):
        """
        Returns the estimated vertical error (see next function for details). 
        If none was stored, returns BVT_NAV_NO_DATA.
        """
        error_meters = c_float()
        error_code = dll.BVTNavData_GetVerticalPrecisionError(self._handle, byref(error_meters))
        if (0 != error_code):
            raise sdkerror.SDKError(error_code)
        return error_meters.value

    def try_get_vertical_precision_error(self, default_value):
        """
        Returns the estimated vertical error (see next function for details). 
        If none was stored, returns BVT_NAV_NO_DATA.
        """
        error_meters = c_float()
        error_code = dll.BVTNavData_GetVerticalPrecisionError(self._handle, byref(error_meters))
        if (0 != error_code):
            return default_value
        return error_meters.value

    @property
    def vertical_precision_error_timestamp(self):
        """
        Returns the Unix epoch time at which the field was set, including fractional seconds. 
        If no data was stored, the returns zero.
        NOTE: Timestamps are generated based on the value of the system clock at the time the
        field was set. As such, they are subject to substantial error due to clock drift and
        system latency and are in no way synchronized to any global standard. If such synchronization
        is required, please use the NavTime field and consider using a PPS signal.
        """
        timestamp = c_double()
        error_code = dll.BVTNavData_GetVerticalPrecisionErrorTimestamp(self._handle, byref(timestamp))
        if (0 != error_code):
            raise sdkerror.SDKError(error_code)
        return timestamp.value

    @vertical_precision_error.setter
    def vertical_precision_error(self, error_meters):
        """
        Stores the estimated possible vertical error (height) above 
        Mean Sea Level (EGM96 geoid).  For other notes, see the functions
        or Horizontal Precision Error, above.
        """
        error_code = dll.BVTNavData_SetVerticalPrecisionError(self._handle, error_meters)
        if (0 != error_code):
            raise sdkerror.SDKError(error_code)

    @property
    def depth(self):
        """
        Returns the depth. If no value was stored for this ping, returns
        BVT_NAV_NO_DATA.
        """
        meters_below_surface = c_float()
        error_code = dll.BVTNavData_GetDepth(self._handle, byref(meters_below_surface))
        if (0 != error_code):
            raise sdkerror.SDKError(error_code)
        return meters_below_surface.value

    def try_get_depth(self, default_value):
        """
        Returns the depth. If no value was stored for this ping, returns
        BVT_NAV_NO_DATA.
        """
        meters_below_surface = c_float()
        error_code = dll.BVTNavData_GetDepth(self._handle, byref(meters_below_surface))
        if (0 != error_code):
            return default_value
        return meters_below_surface.value

    @property
    def depth_timestamp(self):
        """
        Returns the Unix epoch time at which the field was set, including fractional seconds. 
        If no data was stored, the returns zero.
        NOTE: Timestamps are generated based on the value of the system clock at the time the
        field was set. As such, they are subject to substantial error due to clock drift and
        system latency and are in no way synchronized to any global standard. If such synchronization
        is required, please use the NavTime field and consider using a PPS signal.
        """
        timestamp = c_double()
        error_code = dll.BVTNavData_GetDepthTimestamp(self._handle, byref(timestamp))
        if (0 != error_code):
            raise sdkerror.SDKError(error_code)
        return timestamp.value

    @depth.setter
    def depth(self, meters_below_surface):
        """
        Store the depth.
        """
        error_code = dll.BVTNavData_SetDepth(self._handle, meters_below_surface)
        if (0 != error_code):
            raise sdkerror.SDKError(error_code)

    @property
    def altitude(self):
        """
        Returns the altitude. If no value was stored for this ping, returns
        BVT_NAV_NO_DATA.
        """
        meters_above_bottom = c_float()
        error_code = dll.BVTNavData_GetAltitude(self._handle, byref(meters_above_bottom))
        if (0 != error_code):
            raise sdkerror.SDKError(error_code)
        return meters_above_bottom.value

    def try_get_altitude(self, default_value):
        """
        Returns the altitude. If no value was stored for this ping, returns
        BVT_NAV_NO_DATA.
        """
        meters_above_bottom = c_float()
        error_code = dll.BVTNavData_GetAltitude(self._handle, byref(meters_above_bottom))
        if (0 != error_code):
            return default_value
        return meters_above_bottom.value

    @property
    def altitude_timestamp(self):
        """
        Returns the Unix epoch time at which the field was set, including fractional seconds. 
        If no data was stored, the returns zero.
        NOTE: Timestamps are generated based on the value of the system clock at the time the
        field was set. As such, they are subject to substantial error due to clock drift and
        system latency and are in no way synchronized to any global standard. If such synchronization
        is required, please use the NavTime field and consider using a PPS signal.
        """
        timestamp = c_double()
        error_code = dll.BVTNavData_GetAltitudeTimestamp(self._handle, byref(timestamp))
        if (0 != error_code):
            raise sdkerror.SDKError(error_code)
        return timestamp.value

    @altitude.setter
    def altitude(self, meters_above_bottom):
        """
        Store the altitude.
        """
        error_code = dll.BVTNavData_SetAltitude(self._handle, meters_above_bottom)
        if (0 != error_code):
            raise sdkerror.SDKError(error_code)

    @property
    def heading(self):
        """
        Returns the heading relative to True North. If no value was stored
        for this ping, returns BVT_NAV_NO_DATA.
        """
        degrees_true = c_float()
        error_code = dll.BVTNavData_GetHeading(self._handle, byref(degrees_true))
        if (0 != error_code):
            raise sdkerror.SDKError(error_code)
        return degrees_true.value

    def try_get_heading(self, default_value):
        """
        Returns the heading relative to True North. If no value was stored
        for this ping, returns BVT_NAV_NO_DATA.
        """
        degrees_true = c_float()
        error_code = dll.BVTNavData_GetHeading(self._handle, byref(degrees_true))
        if (0 != error_code):
            return default_value
        return degrees_true.value

    @property
    def heading_timestamp(self):
        """
        Returns the Unix epoch time at which the field was set, including fractional seconds. 
        If no data was stored, the returns zero.
        NOTE: Timestamps are generated based on the value of the system clock at the time the
        field was set. As such, they are subject to substantial error due to clock drift and
        system latency and are in no way synchronized to any global standard. If such synchronization
        is required, please use the NavTime field and consider using a PPS signal.
        """
        timestamp = c_double()
        error_code = dll.BVTNavData_GetHeadingTimestamp(self._handle, byref(timestamp))
        if (0 != error_code):
            raise sdkerror.SDKError(error_code)
        return timestamp.value

    @heading.setter
    def heading(self, degrees_true):
        """
        Store the heading relative to True North.
        """
        error_code = dll.BVTNavData_SetHeading(self._handle, degrees_true)
        if (0 != error_code):
            raise sdkerror.SDKError(error_code)

    @property
    def heading_velocity(self):
        """
        Returns the velocity along the heading. If no value was stored
        for this ping, returns BVT_NAV_NO_DATA.
        """
        meters_per_second = c_float()
        error_code = dll.BVTNavData_GetHeadingVelocity(self._handle, byref(meters_per_second))
        if (0 != error_code):
            raise sdkerror.SDKError(error_code)
        return meters_per_second.value

    def try_get_heading_velocity(self, default_value):
        """
        Returns the velocity along the heading. If no value was stored
        for this ping, returns BVT_NAV_NO_DATA.
        """
        meters_per_second = c_float()
        error_code = dll.BVTNavData_GetHeadingVelocity(self._handle, byref(meters_per_second))
        if (0 != error_code):
            return default_value
        return meters_per_second.value

    @property
    def heading_velocity_timestamp(self):
        """
        Returns the Unix epoch time at which the field was set, including fractional seconds. 
        If no data was stored, the returns zero.
        NOTE: Timestamps are generated based on the value of the system clock at the time the
        field was set. As such, they are subject to substantial error due to clock drift and
        system latency and are in no way synchronized to any global standard. If such synchronization
        is required, please use the NavTime field and consider using a PPS signal.
        """
        timestamp = c_double()
        error_code = dll.BVTNavData_GetHeadingVelocityTimestamp(self._handle, byref(timestamp))
        if (0 != error_code):
            raise sdkerror.SDKError(error_code)
        return timestamp.value

    @heading_velocity.setter
    def heading_velocity(self, meters_per_second):
        """
        Store the velocity along the heading.
        """
        error_code = dll.BVTNavData_SetHeadingVelocity(self._handle, meters_per_second)
        if (0 != error_code):
            raise sdkerror.SDKError(error_code)

    @property
    def course_over_ground(self):
        """
        Returns the course over ground (true). If no value was stored for
        this ping, returns BVT_NAV_NO_DATA.
        """
        degrees_true = c_float()
        error_code = dll.BVTNavData_GetCourseOverGround(self._handle, byref(degrees_true))
        if (0 != error_code):
            raise sdkerror.SDKError(error_code)
        return degrees_true.value

    def try_get_course_over_ground(self, default_value):
        """
        Returns the course over ground (true). If no value was stored for
        this ping, returns BVT_NAV_NO_DATA.
        """
        degrees_true = c_float()
        error_code = dll.BVTNavData_GetCourseOverGround(self._handle, byref(degrees_true))
        if (0 != error_code):
            return default_value
        return degrees_true.value

    @property
    def course_over_ground_timestamp(self):
        """
        Returns the Unix epoch time at which the field was set, including fractional seconds. 
        If no data was stored, the returns zero.
        NOTE: Timestamps are generated based on the value of the system clock at the time the
        field was set. As such, they are subject to substantial error due to clock drift and
        system latency and are in no way synchronized to any global standard. If such synchronization
        is required, please use the NavTime field and consider using a PPS signal.
        """
        timestamp = c_double()
        error_code = dll.BVTNavData_GetCourseOverGroundTimestamp(self._handle, byref(timestamp))
        if (0 != error_code):
            raise sdkerror.SDKError(error_code)
        return timestamp.value

    @course_over_ground.setter
    def course_over_ground(self, degrees_true):
        """
        Store the course over ground, true.
        """
        error_code = dll.BVTNavData_SetCourseOverGround(self._handle, degrees_true)
        if (0 != error_code):
            raise sdkerror.SDKError(error_code)

    @property
    def speed_over_ground(self):
        """
        Returns the speed over ground. If no value was stored for this ping,
        returns BVT_NAV_NO_DATA.
        """
        meters_per_second = c_float()
        error_code = dll.BVTNavData_GetSpeedOverGround(self._handle, byref(meters_per_second))
        if (0 != error_code):
            raise sdkerror.SDKError(error_code)
        return meters_per_second.value

    def try_get_speed_over_ground(self, default_value):
        """
        Returns the speed over ground. If no value was stored for this ping,
        returns BVT_NAV_NO_DATA.
        """
        meters_per_second = c_float()
        error_code = dll.BVTNavData_GetSpeedOverGround(self._handle, byref(meters_per_second))
        if (0 != error_code):
            return default_value
        return meters_per_second.value

    @property
    def speed_over_ground_timestamp(self):
        """
        Returns the Unix epoch time at which the field was set, including fractional seconds. 
        If no data was stored, the returns zero.
        NOTE: Timestamps are generated based on the value of the system clock at the time the
        field was set. As such, they are subject to substantial error due to clock drift and
        system latency and are in no way synchronized to any global standard. If such synchronization
        is required, please use the NavTime field and consider using a PPS signal.
        """
        timestamp = c_double()
        error_code = dll.BVTNavData_GetSpeedOverGroundTimestamp(self._handle, byref(timestamp))
        if (0 != error_code):
            raise sdkerror.SDKError(error_code)
        return timestamp.value

    @speed_over_ground.setter
    def speed_over_ground(self, meters_per_second):
        """
        Store the speed over ground.
        """
        error_code = dll.BVTNavData_SetSpeedOverGround(self._handle, meters_per_second)
        if (0 != error_code):
            raise sdkerror.SDKError(error_code)

    @property
    def pitch_angle(self):
        """
        Get the pitch angle. If no value was stored for this ping, returns BVT_NAV_NO_DATA.
        """
        degrees_bow_up = c_float()
        error_code = dll.BVTNavData_GetPitchAngle(self._handle, byref(degrees_bow_up))
        if (0 != error_code):
            raise sdkerror.SDKError(error_code)
        return degrees_bow_up.value

    def try_get_pitch_angle(self, default_value):
        """
        Get the pitch angle. If no value was stored for this ping, returns BVT_NAV_NO_DATA.
        """
        degrees_bow_up = c_float()
        error_code = dll.BVTNavData_GetPitchAngle(self._handle, byref(degrees_bow_up))
        if (0 != error_code):
            return default_value
        return degrees_bow_up.value

    @property
    def pitch_angle_timestamp(self):
        """
        Returns the Unix epoch time at which the field was set, including fractional seconds. 
        If no data was stored, the returns zero.
        NOTE: Timestamps are generated based on the value of the system clock at the time the
        field was set. As such, they are subject to substantial error due to clock drift and
        system latency and are in no way synchronized to any global standard. If such synchronization
        is required, please use the NavTime field and consider using a PPS signal.
        """
        timestamp = c_double()
        error_code = dll.BVTNavData_GetPitchAngleTimestamp(self._handle, byref(timestamp))
        if (0 != error_code):
            raise sdkerror.SDKError(error_code)
        return timestamp.value

    @pitch_angle.setter
    def pitch_angle(self, degrees_bow_up):
        """
        Store the pitch angle.
        """
        error_code = dll.BVTNavData_SetPitchAngle(self._handle, degrees_bow_up)
        if (0 != error_code):
            raise sdkerror.SDKError(error_code)

    @property
    def roll_angle(self):
        """
        Get the roll angle. If no value was stored for this ping, returns BVT_NAV_NO_DATA.
        """
        degrees_port_up = c_float()
        error_code = dll.BVTNavData_GetRollAngle(self._handle, byref(degrees_port_up))
        if (0 != error_code):
            raise sdkerror.SDKError(error_code)
        return degrees_port_up.value

    def try_get_roll_angle(self, default_value):
        """
        Get the roll angle. If no value was stored for this ping, returns BVT_NAV_NO_DATA.
        """
        degrees_port_up = c_float()
        error_code = dll.BVTNavData_GetRollAngle(self._handle, byref(degrees_port_up))
        if (0 != error_code):
            return default_value
        return degrees_port_up.value

    @property
    def roll_angle_timestamp(self):
        """
        Returns the Unix epoch time at which the field was set, including fractional seconds. 
        If no data was stored, the returns zero.
        NOTE: Timestamps are generated based on the value of the system clock at the time the
        field was set. As such, they are subject to substantial error due to clock drift and
        system latency and are in no way synchronized to any global standard. If such synchronization
        is required, please use the NavTime field and consider using a PPS signal.
        """
        timestamp = c_double()
        error_code = dll.BVTNavData_GetRollAngleTimestamp(self._handle, byref(timestamp))
        if (0 != error_code):
            raise sdkerror.SDKError(error_code)
        return timestamp.value

    @roll_angle.setter
    def roll_angle(self, degrees_port_up):
        """
        Store the roll angle.
        """
        error_code = dll.BVTNavData_SetRollAngle(self._handle, degrees_port_up)
        if (0 != error_code):
            raise sdkerror.SDKError(error_code)

    @property
    def yaw_angle(self):
        """
        Get the roll angle (but see notes with SetYawAngle() ). If no value was stored for this ping, returns BVT_NAV_NO_DATA.
        """
        degrees_bow_to_starboard = c_float()
        error_code = dll.BVTNavData_GetYawAngle(self._handle, byref(degrees_bow_to_starboard))
        if (0 != error_code):
            raise sdkerror.SDKError(error_code)
        return degrees_bow_to_starboard.value

    def try_get_yaw_angle(self, default_value):
        """
        Get the roll angle (but see notes with SetYawAngle() ). If no value was stored for this ping, returns BVT_NAV_NO_DATA.
        """
        degrees_bow_to_starboard = c_float()
        error_code = dll.BVTNavData_GetYawAngle(self._handle, byref(degrees_bow_to_starboard))
        if (0 != error_code):
            return default_value
        return degrees_bow_to_starboard.value

    @property
    def yaw_angle_timestamp(self):
        """
        Returns the Unix epoch time at which the field was set, including fractional seconds. 
        If no data was stored, the returns zero.
        NOTE: Timestamps are generated based on the value of the system clock at the time the
        field was set. As such, they are subject to substantial error due to clock drift and
        system latency and are in no way synchronized to any global standard. If such synchronization
        is required, please use the NavTime field and consider using a PPS signal.
        """
        timestamp = c_double()
        error_code = dll.BVTNavData_GetYawAngleTimestamp(self._handle, byref(timestamp))
        if (0 != error_code):
            raise sdkerror.SDKError(error_code)
        return timestamp.value

    @yaw_angle.setter
    def yaw_angle(self, degrees_bow_to_starboard):
        """
        Store the yaw angle. <br>
        NOTE: This is NOT the same as the Heading field. Heading is for the
        normal navigation use of Heading, often from a compass. This field is
        intended to store raw data from other research instruments, in case
        you need another storage spot. To keep everyone using the fields the
        same way so that files can be interchanged, please use SetHeading
        for the normal heading, and SetYawAngle() only for special uses.
        """
        error_code = dll.BVTNavData_SetYawAngle(self._handle, degrees_bow_to_starboard)
        if (0 != error_code):
            raise sdkerror.SDKError(error_code)

    @property
    def pitch_rate(self):
        """
        Returns the rate of pitch change.
        If no value was stored for this ping, returns BVT_NAV_NO_DATA.
        """
        degrees_per_second = c_float()
        error_code = dll.BVTNavData_GetPitchRate(self._handle, byref(degrees_per_second))
        if (0 != error_code):
            raise sdkerror.SDKError(error_code)
        return degrees_per_second.value

    def try_get_pitch_rate(self, default_value):
        """
        Returns the rate of pitch change.
        If no value was stored for this ping, returns BVT_NAV_NO_DATA.
        """
        degrees_per_second = c_float()
        error_code = dll.BVTNavData_GetPitchRate(self._handle, byref(degrees_per_second))
        if (0 != error_code):
            return default_value
        return degrees_per_second.value

    @property
    def pitch_rate_timestamp(self):
        """
        Returns the Unix epoch time at which the field was set, including fractional seconds. 
        If no data was stored, the returns zero.
        NOTE: Timestamps are generated based on the value of the system clock at the time the
        field was set. As such, they are subject to substantial error due to clock drift and
        system latency and are in no way synchronized to any global standard. If such synchronization
        is required, please use the NavTime field and consider using a PPS signal.
        """
        timestamp = c_double()
        error_code = dll.BVTNavData_GetPitchRateTimestamp(self._handle, byref(timestamp))
        if (0 != error_code):
            raise sdkerror.SDKError(error_code)
        return timestamp.value

    @pitch_rate.setter
    def pitch_rate(self, degrees_per_second):
        """
        Store the the rate of pitch change.
        """
        error_code = dll.BVTNavData_SetPitchRate(self._handle, degrees_per_second)
        if (0 != error_code):
            raise sdkerror.SDKError(error_code)

    @property
    def roll_rate(self):
        """
        Returns the rate of roll change.
        If no value was stored for this ping, returns BVT_NAV_NO_DATA.
        """
        degrees_per_second = c_float()
        error_code = dll.BVTNavData_GetRollRate(self._handle, byref(degrees_per_second))
        if (0 != error_code):
            raise sdkerror.SDKError(error_code)
        return degrees_per_second.value

    def try_get_roll_rate(self, default_value):
        """
        Returns the rate of roll change.
        If no value was stored for this ping, returns BVT_NAV_NO_DATA.
        """
        degrees_per_second = c_float()
        error_code = dll.BVTNavData_GetRollRate(self._handle, byref(degrees_per_second))
        if (0 != error_code):
            return default_value
        return degrees_per_second.value

    @property
    def roll_rate_timestamp(self):
        """
        Returns the Unix epoch time at which the field was set, including fractional seconds. 
        If no data was stored, the returns zero.
        NOTE: Timestamps are generated based on the value of the system clock at the time the
        field was set. As such, they are subject to substantial error due to clock drift and
        system latency and are in no way synchronized to any global standard. If such synchronization
        is required, please use the NavTime field and consider using a PPS signal.
        """
        timestamp = c_double()
        error_code = dll.BVTNavData_GetRollRateTimestamp(self._handle, byref(timestamp))
        if (0 != error_code):
            raise sdkerror.SDKError(error_code)
        return timestamp.value

    @roll_rate.setter
    def roll_rate(self, degrees_per_second):
        """
        Store the the rate of change in roll.
        """
        error_code = dll.BVTNavData_SetRollRate(self._handle, degrees_per_second)
        if (0 != error_code):
            raise sdkerror.SDKError(error_code)

    @property
    def yaw_rate(self):
        """
        Returns the rate of change in yaw (heading).  If no value was stored for this ping,
        returns BVT_NAV_NO_DATA.
        """
        degrees_per_second = c_float()
        error_code = dll.BVTNavData_GetYawRate(self._handle, byref(degrees_per_second))
        if (0 != error_code):
            raise sdkerror.SDKError(error_code)
        return degrees_per_second.value

    def try_get_yaw_rate(self, default_value):
        """
        Returns the rate of change in yaw (heading).  If no value was stored for this ping,
        returns BVT_NAV_NO_DATA.
        """
        degrees_per_second = c_float()
        error_code = dll.BVTNavData_GetYawRate(self._handle, byref(degrees_per_second))
        if (0 != error_code):
            return default_value
        return degrees_per_second.value

    @property
    def yaw_rate_timestamp(self):
        """
        Returns the Unix epoch time at which the field was set, including fractional seconds. 
        If no data was stored, the returns zero.
        NOTE: Timestamps are generated based on the value of the system clock at the time the
        field was set. As such, they are subject to substantial error due to clock drift and
        system latency and are in no way synchronized to any global standard. If such synchronization
        is required, please use the NavTime field and consider using a PPS signal.
        """
        timestamp = c_double()
        error_code = dll.BVTNavData_GetYawRateTimestamp(self._handle, byref(timestamp))
        if (0 != error_code):
            raise sdkerror.SDKError(error_code)
        return timestamp.value

    @yaw_rate.setter
    def yaw_rate(self, degrees_per_second):
        """
        Store the rate of change in yaw (heading).
        """
        error_code = dll.BVTNavData_SetYawRate(self._handle, degrees_per_second)
        if (0 != error_code):
            raise sdkerror.SDKError(error_code)

    @property
    def acceleration_x(self):
        """
        Gets the stored acceleration along the X axis. If no value was stored for this ping,
        returns BVT_NAV_NO_DATA.
        """
        accel_mg = c_float()
        error_code = dll.BVTNavData_GetAccelerationX(self._handle, byref(accel_mg))
        if (0 != error_code):
            raise sdkerror.SDKError(error_code)
        return accel_mg.value

    def try_get_acceleration_x(self, default_value):
        """
        Gets the stored acceleration along the X axis. If no value was stored for this ping,
        returns BVT_NAV_NO_DATA.
        """
        accel_mg = c_float()
        error_code = dll.BVTNavData_GetAccelerationX(self._handle, byref(accel_mg))
        if (0 != error_code):
            return default_value
        return accel_mg.value

    @property
    def acceleration_x_timestamp(self):
        """
        Returns the Unix epoch time at which the field was set, including fractional seconds. 
        If no data was stored, the returns zero.
        NOTE: Timestamps are generated based on the value of the system clock at the time the
        field was set. As such, they are subject to substantial error due to clock drift and
        system latency and are in no way synchronized to any global standard. If such synchronization
        is required, please use the NavTime field and consider using a PPS signal.
        """
        timestamp = c_double()
        error_code = dll.BVTNavData_GetAccelerationXTimestamp(self._handle, byref(timestamp))
        if (0 != error_code):
            raise sdkerror.SDKError(error_code)
        return timestamp.value

    @acceleration_x.setter
    def acceleration_x(self, accel_mg):
        """
        Sets the stored acceleration along the X axis. Intended to store
        raw values of accelerometers.
        """
        error_code = dll.BVTNavData_SetAccelerationX(self._handle, accel_mg)
        if (0 != error_code):
            raise sdkerror.SDKError(error_code)

    @property
    def acceleration_y(self):
        """
        Gets the stored acceleration along the Y axis. If no value was stored for this ping,
        returns BVT_NAV_NO_DATA.
        """
        accel_mg = c_float()
        error_code = dll.BVTNavData_GetAccelerationY(self._handle, byref(accel_mg))
        if (0 != error_code):
            raise sdkerror.SDKError(error_code)
        return accel_mg.value

    def try_get_acceleration_y(self, default_value):
        """
        Gets the stored acceleration along the Y axis. If no value was stored for this ping,
        returns BVT_NAV_NO_DATA.
        """
        accel_mg = c_float()
        error_code = dll.BVTNavData_GetAccelerationY(self._handle, byref(accel_mg))
        if (0 != error_code):
            return default_value
        return accel_mg.value

    @property
    def acceleration_y_timestamp(self):
        """
        Returns the Unix epoch time at which the field was set, including fractional seconds. 
        If no data was stored, the returns zero.
        NOTE: Timestamps are generated based on the value of the system clock at the time the
        field was set. As such, they are subject to substantial error due to clock drift and
        system latency and are in no way synchronized to any global standard. If such synchronization
        is required, please use the NavTime field and consider using a PPS signal.
        """
        timestamp = c_double()
        error_code = dll.BVTNavData_GetAccelerationYTimestamp(self._handle, byref(timestamp))
        if (0 != error_code):
            raise sdkerror.SDKError(error_code)
        return timestamp.value

    @acceleration_y.setter
    def acceleration_y(self, accel_mg):
        """
        Sets the stored acceleration along the Y axis. Intended to store
        raw values of accelerometers.
        """
        error_code = dll.BVTNavData_SetAccelerationY(self._handle, accel_mg)
        if (0 != error_code):
            raise sdkerror.SDKError(error_code)

    @property
    def acceleration_z(self):
        """
        Gets the stored acceleration along the Z axis. If no value was stored for this ping,
        returns BVT_NAV_NO_DATA.
        """
        accel_mg = c_float()
        error_code = dll.BVTNavData_GetAccelerationZ(self._handle, byref(accel_mg))
        if (0 != error_code):
            raise sdkerror.SDKError(error_code)
        return accel_mg.value

    def try_get_acceleration_z(self, default_value):
        """
        Gets the stored acceleration along the Z axis. If no value was stored for this ping,
        returns BVT_NAV_NO_DATA.
        """
        accel_mg = c_float()
        error_code = dll.BVTNavData_GetAccelerationZ(self._handle, byref(accel_mg))
        if (0 != error_code):
            return default_value
        return accel_mg.value

    @property
    def acceleration_z_timestamp(self):
        """
        Returns the Unix epoch time at which the field was set, including fractional seconds. 
        If no data was stored, the returns zero.
        NOTE: Timestamps are generated based on the value of the system clock at the time the
        field was set. As such, they are subject to substantial error due to clock drift and
        system latency and are in no way synchronized to any global standard. If such synchronization
        is required, please use the NavTime field and consider using a PPS signal.
        """
        timestamp = c_double()
        error_code = dll.BVTNavData_GetAccelerationZTimestamp(self._handle, byref(timestamp))
        if (0 != error_code):
            raise sdkerror.SDKError(error_code)
        return timestamp.value

    @acceleration_z.setter
    def acceleration_z(self, accel_mg):
        """
        Sets the stored acceleration along the Z axis. Intended to store
        raw values of accelerometers.
        """
        error_code = dll.BVTNavData_SetAccelerationZ(self._handle, accel_mg)
        if (0 != error_code):
            raise sdkerror.SDKError(error_code)

    @property
    def offset_north(self):
        """
        Returns the offset, to the north, from a user-defined fixed point.
        If no value was stored for this ping, returns BVT_NAV_NO_DATA.
        """
        meters = c_double()
        error_code = dll.BVTNavData_GetOffsetNorth(self._handle, byref(meters))
        if (0 != error_code):
            raise sdkerror.SDKError(error_code)
        return meters.value

    def try_get_offset_north(self, default_value):
        """
        Returns the offset, to the north, from a user-defined fixed point.
        If no value was stored for this ping, returns BVT_NAV_NO_DATA.
        """
        meters = c_double()
        error_code = dll.BVTNavData_GetOffsetNorth(self._handle, byref(meters))
        if (0 != error_code):
            return default_value
        return meters.value

    @property
    def offset_north_timestamp(self):
        """
        Returns the Unix epoch time at which the field was set, including fractional seconds. 
        If no data was stored, the returns zero.
        NOTE: Timestamps are generated based on the value of the system clock at the time the
        field was set. As such, they are subject to substantial error due to clock drift and
        system latency and are in no way synchronized to any global standard. If such synchronization
        is required, please use the NavTime field and consider using a PPS signal.
        """
        timestamp = c_double()
        error_code = dll.BVTNavData_GetOffsetNorthTimestamp(self._handle, byref(timestamp))
        if (0 != error_code):
            raise sdkerror.SDKError(error_code)
        return timestamp.value

    @offset_north.setter
    def offset_north(self, meters):
        """
        Store the offset from a user-defined fixed point.
        """
        error_code = dll.BVTNavData_SetOffsetNorth(self._handle, meters)
        if (0 != error_code):
            raise sdkerror.SDKError(error_code)

    @property
    def offset_east(self):
        """
        Returns the offset, to the east, from a user-defined fixed point.
        If no value was stored for this ping, returns BVT_NAV_NO_DATA.
        """
        meters = c_double()
        error_code = dll.BVTNavData_GetOffsetEast(self._handle, byref(meters))
        if (0 != error_code):
            raise sdkerror.SDKError(error_code)
        return meters.value

    def try_get_offset_east(self, default_value):
        """
        Returns the offset, to the east, from a user-defined fixed point.
        If no value was stored for this ping, returns BVT_NAV_NO_DATA.
        """
        meters = c_double()
        error_code = dll.BVTNavData_GetOffsetEast(self._handle, byref(meters))
        if (0 != error_code):
            return default_value
        return meters.value

    @property
    def offset_east_timestamp(self):
        """
        Returns the Unix epoch time at which the field was set, including fractional seconds. 
        If no data was stored, the returns zero.
        NOTE: Timestamps are generated based on the value of the system clock at the time the
        field was set. As such, they are subject to substantial error due to clock drift and
        system latency and are in no way synchronized to any global standard. If such synchronization
        is required, please use the NavTime field and consider using a PPS signal.
        """
        timestamp = c_double()
        error_code = dll.BVTNavData_GetOffsetEastTimestamp(self._handle, byref(timestamp))
        if (0 != error_code):
            raise sdkerror.SDKError(error_code)
        return timestamp.value

    @offset_east.setter
    def offset_east(self, meters):
        """
        Store the offset from a user-defined fixed point.
        """
        error_code = dll.BVTNavData_SetOffsetEast(self._handle, meters)
        if (0 != error_code):
            raise sdkerror.SDKError(error_code)

    @property
    def offset_is_from_lat_long_flag(self):
        """
        Gets a flag value which indicates if the East and North offset values
        are from the stored Latitude and Longitude. (see more below...)
        If no value was stored for this ping, returns BVT_NAV_NO_DATA.
        """
        is_true = c_int()
        error_code = dll.BVTNavData_GetOffsetIsFromLatLongFlag(self._handle, byref(is_true))
        if (0 != error_code):
            raise sdkerror.SDKError(error_code)
        return is_true.value

    def try_get_offset_is_from_lat_long_flag(self, default_value):
        """
        Gets a flag value which indicates if the East and North offset values
        are from the stored Latitude and Longitude. (see more below...)
        If no value was stored for this ping, returns BVT_NAV_NO_DATA.
        """
        is_true = c_int()
        error_code = dll.BVTNavData_GetOffsetIsFromLatLongFlag(self._handle, byref(is_true))
        if (0 != error_code):
            return default_value
        return is_true.value

    @property
    def offset_is_from_lat_long_flag_timestamp(self):
        """
        Returns the Unix epoch time at which the field was set, including fractional seconds. 
        If no data was stored, the returns zero.
        NOTE: Timestamps are generated based on the value of the system clock at the time the
        field was set. As such, they are subject to substantial error due to clock drift and
        system latency and are in no way synchronized to any global standard. If such synchronization
        is required, please use the NavTime field and consider using a PPS signal.
        """
        timestamp = c_double()
        error_code = dll.BVTNavData_GetOffsetIsFromLatLongFlagTimestamp(self._handle, byref(timestamp))
        if (0 != error_code):
            raise sdkerror.SDKError(error_code)
        return timestamp.value

    @offset_is_from_lat_long_flag.setter
    def offset_is_from_lat_long_flag(self, is_true):
        """
        Sets a flag to indicate if the East and North offset values are from
        the stored Latitude and Longitude. If so, then software reading the
        file will know to adjust appropriately. If from some special location,
        perhaps the UserNavString could be used to indicate the reference
        point? If nothing is stored, then the value is assumed to be false.
        """
        error_code = dll.BVTNavData_SetOffsetIsFromLatLongFlag(self._handle, is_true)
        if (0 != error_code):
            raise sdkerror.SDKError(error_code)

    @property
    def user_nav_string(self):
        """
        Returns the stored user string, in null-terminated form. If no
        string was stored, returns a null string.
        """
        bufferLength = 255
        navString = create_string_buffer(buffer_size)
        error_code = dll.BVTNavData_GetUserNavString(self._handle, navString, bufferLength)
        if (0 != error_code):
            raise sdkerror.SDKError(error_code)
        return (navString.value)

    @property
    def user_nav_string_timestamp(self):
        """
        Returns the Unix epoch time at which the field was set, including fractional seconds. 
        If no data was stored, the returns zero.
        NOTE: Timestamps are generated based on the value of the system clock at the time the
        field was set. As such, they are subject to substantial error due to clock drift and
        system latency and are in no way synchronized to any global standard. If such synchronization
        is required, please use the NavTime field and consider using a PPS signal.
        """
        timestamp = c_double()
        error_code = dll.BVTNavData_GetUserNavStringTimestamp(self._handle, byref(timestamp))
        if (0 != error_code):
            raise sdkerror.SDKError(error_code)
        return timestamp.value

    @user_nav_string.setter
    def user_nav_string(self, string_in):
        """
        Stores a user-defined string related to navigation. It is highly
        recommended to store some identifier such that the data is
        recognizable as you own. <br>
        Examples of possible uses might be to store locations based on 
        coordinate systems other than GPS, indicating information about
        the use of the north and east offset parameters, additional fields
        from a GPS receiver, or any other information which might change
        dynamically.
        """
        error_code = dll.BVTNavData_SetUserNavString(self._handle, (string_in))
        if (0 != error_code):
            raise sdkerror.SDKError(error_code)

    @property
    def source(self):
        """
        Returns the stored Source string, in null-terminated form. If no
        string was stored, returns a null string.
        """
        source_string_length = 255
        source_string = create_string_buffer(buffer_size)
        error_code = dll.BVTNavData_GetSource(self._handle, source_string, source_string_length)
        if (0 != error_code):
            raise sdkerror.SDKError(error_code)
        return (source_string.value)

    @property
    def source_length(self):
        """
        Returns the length of the stored Source string.
        """
        source_string_length = c_int()
        error_code = dll.BVTNavData_GetSourceLength(self._handle, byref(source_string_length))
        if (0 != error_code):
            raise sdkerror.SDKError(error_code)
        return source_string_length.value

    @property
    def source_timestamp(self):
        """
        Returns the Unix epoch time at which the field was set, including fractional seconds. 
        If no data was stored, the returns zero.
        NOTE: Timestamps are generated based on the value of the system clock at the time the
        field was set. As such, they are subject to substantial error due to clock drift and
        system latency and are in no way synchronized to any global standard. If such synchronization
        is required, please use the NavTime field and consider using a PPS signal.
        """
        timestamp = c_double()
        error_code = dll.BVTNavData_GetSourceTimestamp(self._handle, byref(timestamp))
        if (0 != error_code):
            raise sdkerror.SDKError(error_code)
        return timestamp.value

    @source.setter
    def source(self, source_string):
        """
        Stores a user-defined string which identifies the NavData source, 
        e.g. "MRU", "GPS", "Compass". <br>.
        """
        error_code = dll.BVTNavData_SetSource(self._handle, (source_string))
        if (0 != error_code):
            raise sdkerror.SDKError(error_code)

    @property
    def utm_longitude_zone(self):
        """
        Returns the stored UTM zone and grid number, in null-terminated form. If no
        string was stored, returns a null string.
        """
        bufLength = 255
        zone = create_string_buffer(buffer_size)
        error_code = dll.BVTNavData_GetUTMLongitudeZone(self._handle, zone, bufLength)
        if (0 != error_code):
            raise sdkerror.SDKError(error_code)
        return (zone.value)

    @property
    def utm_longitude_zone_timestamp(self):
        """
        Returns the Unix epoch time at which the field was set, including fractional seconds. 
        If no data was stored, the returns zero.
        NOTE: Timestamps are generated based on the value of the system clock at the time the
        field was set. As such, they are subject to substantial error due to clock drift and
        system latency and are in no way synchronized to any global standard. If such synchronization
        is required, please use the NavTime field and consider using a PPS signal.
        """
        timestamp = c_double()
        error_code = dll.BVTNavData_GetUTMLongitudeZoneTimestamp(self._handle, byref(timestamp))
        if (0 != error_code):
            raise sdkerror.SDKError(error_code)
        return timestamp.value

    @utm_longitude_zone.setter
    def utm_longitude_zone(self, zone_string):
        """
        Stores a string which identifies the UTM Zone and grid used as the
        basis for Northing and Easting values. Zones range from [1,60], grids are lettered from
        C-X not including O or I. Acceptable strings are of the form "1G" or "03F" or "54T".
        """
        error_code = dll.BVTNavData_SetUTMLongitudeZone(self._handle, (zone_string))
        if (0 != error_code):
            raise sdkerror.SDKError(error_code)

    @property
    def heave_timestamp(self):
        """
        Returns the Unix epoch time at which the field was set, including fractional seconds. 
        If no data was stored, the returns zero.
        NOTE: Timestamps are generated based on the value of the system clock at the time the
        field was set. As such, they are subject to substantial error due to clock drift and
        system latency and are in no way synchronized to any global standard. If such synchronization
        is required, please use the NavTime field and consider using a PPS signal.
        """
        timestamp = c_double()
        error_code = dll.BVTNavData_GetHeaveTimestamp(self._handle, byref(timestamp))
        if (0 != error_code):
            raise sdkerror.SDKError(error_code)
        return timestamp.value

    @property
    def heave(self):
        """
        Gets the stored heave. If no value was stored for this ping,
        returns BVT_NAV_NO_DATA.
        """
        heave_in_meters = c_float()
        error_code = dll.BVTNavData_GetHeave(self._handle, byref(heave_in_meters))
        if (0 != error_code):
            raise sdkerror.SDKError(error_code)
        return heave_in_meters.value

    def try_get_heave(self, default_value):
        """
        Gets the stored heave. If no value was stored for this ping,
        returns BVT_NAV_NO_DATA.
        """
        heave_in_meters = c_float()
        error_code = dll.BVTNavData_GetHeave(self._handle, byref(heave_in_meters))
        if (0 != error_code):
            return default_value
        return heave_in_meters.value

    @heave.setter
    def heave(self, heave_in_meters):
        """
        Stores a heave value, which is expected to be supplied by an MRU.
        """
        error_code = dll.BVTNavData_SetHeave(self._handle, heave_in_meters)
        if (0 != error_code):
            raise sdkerror.SDKError(error_code)

    @property
    def nav_time(self):
        """
        Return the data's timestamp in seconds since 00:00:00 UTC, January 1, 1970 
        NavData is timestamped using a standard UNIX time stamp. This is 
        a similar value to that returned by the time() C standard library 
        function. In fact, the only difference is the addition of fractional seconds.
        """
        seconds = c_double()
        error_code = dll.BVTNavData_GetNavTime(self._handle, byref(seconds))
        if (0 != error_code):
            raise sdkerror.SDKError(error_code)
        return seconds.value

    def try_get_nav_time(self, default_value):
        """
        Return the data's timestamp in seconds since 00:00:00 UTC, January 1, 1970 
        NavData is timestamped using a standard UNIX time stamp. This is 
        a similar value to that returned by the time() C standard library 
        function. In fact, the only difference is the addition of fractional seconds.
        """
        seconds = c_double()
        error_code = dll.BVTNavData_GetNavTime(self._handle, byref(seconds))
        if (0 != error_code):
            return default_value
        return seconds.value

    @property
    def nav_time_timestamp(self):
        """
        Returns the Unix epoch time at which the field was set, including fractional seconds. 
        If no data was stored, the returns zero.
        This field may be compared to the output of GetNavTime() to get a temporary estimate of the offset
        between the system clock and the device clock. Note that this estimate will be subeject to 
        drift.
        NOTE: Timestamps are generated based on the value of the system clock at the time the
        field was set. As such, they are subject to substantial error due to clock drift and
        system latency and are in no way synchronized to any global standard. If such synchronization
        is required, please use the NavTime field and consider using a PPS signal.
        """
        timestamp = c_double()
        error_code = dll.BVTNavData_GetNavTimeTimestamp(self._handle, byref(timestamp))
        if (0 != error_code):
            raise sdkerror.SDKError(error_code)
        return timestamp.value

    @nav_time.setter
    def nav_time(self, sec):
        """
        Set the NavData's internal time stamp.  See GetNavTime() for more information. 
        """
        error_code = dll.BVTNavData_SetNavTime(self._handle, sec)
        if (0 != error_code):
            raise sdkerror.SDKError(error_code)


    def get_handle(self):
        """
        SDK object pointer
        """
        return self._handle
if "win32" in sys.platform:
    dll_name = "bvtsdk4.dll"
elif "darwin" in sys.platform:
    dll_name = "libbvtsdk.dylib"
else:
    dll_name = "libbvtsdk.so"
dll = CDLL(dll_name)
dll.BVTNavData_Create.restype = c_void_p
dll.BVTNavData_Destroy.restype = None
dll.BVTNavData_Destroy.argtypes = (c_void_p,)
dll.BVTNavData_Clone.restype = c_int
dll.BVTNavData_Clone.argtypes = (c_void_p, c_void_p, )
dll.BVTNavData_CloneFrom.restype = c_int
dll.BVTNavData_CloneFrom.argtypes = (c_void_p, c_void_p, )
dll.BVTNavData_Clear.restype = c_int
dll.BVTNavData_Clear.argtypes = (c_void_p, )
dll.BVTNavData_IsEmpty.restype = c_int
dll.BVTNavData_IsEmpty.argtypes = (c_void_p, POINTER(c_int), )
dll.BVTNavData_Merge.restype = c_int
dll.BVTNavData_Merge.argtypes = (c_void_p, c_void_p, )
dll.BVTNavData_ClearStaleFields.restype = c_int
dll.BVTNavData_ClearStaleFields.argtypes = (c_void_p, c_double, POINTER(c_int), )
dll.BVTNavData_GetTimespan.restype = c_int
dll.BVTNavData_GetTimespan.argtypes = (c_void_p, POINTER(c_double), POINTER(c_double), )
dll.BVTNavData_GetLatitude.restype = c_int
dll.BVTNavData_GetLatitude.argtypes = (c_void_p, POINTER(c_double), )
dll.BVTNavData_GetLatitudeTimestamp.restype = c_int
dll.BVTNavData_GetLatitudeTimestamp.argtypes = (c_void_p, POINTER(c_double), )
dll.BVTNavData_SetLatitude.restype = c_int
dll.BVTNavData_SetLatitude.argtypes = (c_void_p, c_double, )
dll.BVTNavData_GetLongitude.restype = c_int
dll.BVTNavData_GetLongitude.argtypes = (c_void_p, POINTER(c_double), )
dll.BVTNavData_GetLongitudeTimestamp.restype = c_int
dll.BVTNavData_GetLongitudeTimestamp.argtypes = (c_void_p, POINTER(c_double), )
dll.BVTNavData_SetLongitude.restype = c_int
dll.BVTNavData_SetLongitude.argtypes = (c_void_p, c_double, )
dll.BVTNavData_GetHorizontalPrecisionError.restype = c_int
dll.BVTNavData_GetHorizontalPrecisionError.argtypes = (c_void_p, POINTER(c_float), )
dll.BVTNavData_GetHorizontalPrecisionErrorTimestamp.restype = c_int
dll.BVTNavData_GetHorizontalPrecisionErrorTimestamp.argtypes = (c_void_p, POINTER(c_double), )
dll.BVTNavData_SetHorizontalPrecisionError.restype = c_int
dll.BVTNavData_SetHorizontalPrecisionError.argtypes = (c_void_p, c_float, )
dll.BVTNavData_GetHeight.restype = c_int
dll.BVTNavData_GetHeight.argtypes = (c_void_p, POINTER(c_float), )
dll.BVTNavData_GetHeightTimestamp.restype = c_int
dll.BVTNavData_GetHeightTimestamp.argtypes = (c_void_p, POINTER(c_double), )
dll.BVTNavData_SetHeight.restype = c_int
dll.BVTNavData_SetHeight.argtypes = (c_void_p, c_float, )
dll.BVTNavData_GetVerticalPrecisionError.restype = c_int
dll.BVTNavData_GetVerticalPrecisionError.argtypes = (c_void_p, POINTER(c_float), )
dll.BVTNavData_GetVerticalPrecisionErrorTimestamp.restype = c_int
dll.BVTNavData_GetVerticalPrecisionErrorTimestamp.argtypes = (c_void_p, POINTER(c_double), )
dll.BVTNavData_SetVerticalPrecisionError.restype = c_int
dll.BVTNavData_SetVerticalPrecisionError.argtypes = (c_void_p, c_float, )
dll.BVTNavData_GetDepth.restype = c_int
dll.BVTNavData_GetDepth.argtypes = (c_void_p, POINTER(c_float), )
dll.BVTNavData_GetDepthTimestamp.restype = c_int
dll.BVTNavData_GetDepthTimestamp.argtypes = (c_void_p, POINTER(c_double), )
dll.BVTNavData_SetDepth.restype = c_int
dll.BVTNavData_SetDepth.argtypes = (c_void_p, c_float, )
dll.BVTNavData_GetAltitude.restype = c_int
dll.BVTNavData_GetAltitude.argtypes = (c_void_p, POINTER(c_float), )
dll.BVTNavData_GetAltitudeTimestamp.restype = c_int
dll.BVTNavData_GetAltitudeTimestamp.argtypes = (c_void_p, POINTER(c_double), )
dll.BVTNavData_SetAltitude.restype = c_int
dll.BVTNavData_SetAltitude.argtypes = (c_void_p, c_float, )
dll.BVTNavData_GetHeading.restype = c_int
dll.BVTNavData_GetHeading.argtypes = (c_void_p, POINTER(c_float), )
dll.BVTNavData_GetHeadingTimestamp.restype = c_int
dll.BVTNavData_GetHeadingTimestamp.argtypes = (c_void_p, POINTER(c_double), )
dll.BVTNavData_SetHeading.restype = c_int
dll.BVTNavData_SetHeading.argtypes = (c_void_p, c_float, )
dll.BVTNavData_GetHeadingVelocity.restype = c_int
dll.BVTNavData_GetHeadingVelocity.argtypes = (c_void_p, POINTER(c_float), )
dll.BVTNavData_GetHeadingVelocityTimestamp.restype = c_int
dll.BVTNavData_GetHeadingVelocityTimestamp.argtypes = (c_void_p, POINTER(c_double), )
dll.BVTNavData_SetHeadingVelocity.restype = c_int
dll.BVTNavData_SetHeadingVelocity.argtypes = (c_void_p, c_float, )
dll.BVTNavData_GetCourseOverGround.restype = c_int
dll.BVTNavData_GetCourseOverGround.argtypes = (c_void_p, POINTER(c_float), )
dll.BVTNavData_GetCourseOverGroundTimestamp.restype = c_int
dll.BVTNavData_GetCourseOverGroundTimestamp.argtypes = (c_void_p, POINTER(c_double), )
dll.BVTNavData_SetCourseOverGround.restype = c_int
dll.BVTNavData_SetCourseOverGround.argtypes = (c_void_p, c_float, )
dll.BVTNavData_GetSpeedOverGround.restype = c_int
dll.BVTNavData_GetSpeedOverGround.argtypes = (c_void_p, POINTER(c_float), )
dll.BVTNavData_GetSpeedOverGroundTimestamp.restype = c_int
dll.BVTNavData_GetSpeedOverGroundTimestamp.argtypes = (c_void_p, POINTER(c_double), )
dll.BVTNavData_SetSpeedOverGround.restype = c_int
dll.BVTNavData_SetSpeedOverGround.argtypes = (c_void_p, c_float, )
dll.BVTNavData_GetPitchAngle.restype = c_int
dll.BVTNavData_GetPitchAngle.argtypes = (c_void_p, POINTER(c_float), )
dll.BVTNavData_GetPitchAngleTimestamp.restype = c_int
dll.BVTNavData_GetPitchAngleTimestamp.argtypes = (c_void_p, POINTER(c_double), )
dll.BVTNavData_SetPitchAngle.restype = c_int
dll.BVTNavData_SetPitchAngle.argtypes = (c_void_p, c_float, )
dll.BVTNavData_GetRollAngle.restype = c_int
dll.BVTNavData_GetRollAngle.argtypes = (c_void_p, POINTER(c_float), )
dll.BVTNavData_GetRollAngleTimestamp.restype = c_int
dll.BVTNavData_GetRollAngleTimestamp.argtypes = (c_void_p, POINTER(c_double), )
dll.BVTNavData_SetRollAngle.restype = c_int
dll.BVTNavData_SetRollAngle.argtypes = (c_void_p, c_float, )
dll.BVTNavData_GetYawAngle.restype = c_int
dll.BVTNavData_GetYawAngle.argtypes = (c_void_p, POINTER(c_float), )
dll.BVTNavData_GetYawAngleTimestamp.restype = c_int
dll.BVTNavData_GetYawAngleTimestamp.argtypes = (c_void_p, POINTER(c_double), )
dll.BVTNavData_SetYawAngle.restype = c_int
dll.BVTNavData_SetYawAngle.argtypes = (c_void_p, c_float, )
dll.BVTNavData_GetPitchRate.restype = c_int
dll.BVTNavData_GetPitchRate.argtypes = (c_void_p, POINTER(c_float), )
dll.BVTNavData_GetPitchRateTimestamp.restype = c_int
dll.BVTNavData_GetPitchRateTimestamp.argtypes = (c_void_p, POINTER(c_double), )
dll.BVTNavData_SetPitchRate.restype = c_int
dll.BVTNavData_SetPitchRate.argtypes = (c_void_p, c_float, )
dll.BVTNavData_GetRollRate.restype = c_int
dll.BVTNavData_GetRollRate.argtypes = (c_void_p, POINTER(c_float), )
dll.BVTNavData_GetRollRateTimestamp.restype = c_int
dll.BVTNavData_GetRollRateTimestamp.argtypes = (c_void_p, POINTER(c_double), )
dll.BVTNavData_SetRollRate.restype = c_int
dll.BVTNavData_SetRollRate.argtypes = (c_void_p, c_float, )
dll.BVTNavData_GetYawRate.restype = c_int
dll.BVTNavData_GetYawRate.argtypes = (c_void_p, POINTER(c_float), )
dll.BVTNavData_GetYawRateTimestamp.restype = c_int
dll.BVTNavData_GetYawRateTimestamp.argtypes = (c_void_p, POINTER(c_double), )
dll.BVTNavData_SetYawRate.restype = c_int
dll.BVTNavData_SetYawRate.argtypes = (c_void_p, c_float, )
dll.BVTNavData_GetAccelerationX.restype = c_int
dll.BVTNavData_GetAccelerationX.argtypes = (c_void_p, POINTER(c_float), )
dll.BVTNavData_GetAccelerationXTimestamp.restype = c_int
dll.BVTNavData_GetAccelerationXTimestamp.argtypes = (c_void_p, POINTER(c_double), )
dll.BVTNavData_SetAccelerationX.restype = c_int
dll.BVTNavData_SetAccelerationX.argtypes = (c_void_p, c_float, )
dll.BVTNavData_GetAccelerationY.restype = c_int
dll.BVTNavData_GetAccelerationY.argtypes = (c_void_p, POINTER(c_float), )
dll.BVTNavData_GetAccelerationYTimestamp.restype = c_int
dll.BVTNavData_GetAccelerationYTimestamp.argtypes = (c_void_p, POINTER(c_double), )
dll.BVTNavData_SetAccelerationY.restype = c_int
dll.BVTNavData_SetAccelerationY.argtypes = (c_void_p, c_float, )
dll.BVTNavData_GetAccelerationZ.restype = c_int
dll.BVTNavData_GetAccelerationZ.argtypes = (c_void_p, POINTER(c_float), )
dll.BVTNavData_GetAccelerationZTimestamp.restype = c_int
dll.BVTNavData_GetAccelerationZTimestamp.argtypes = (c_void_p, POINTER(c_double), )
dll.BVTNavData_SetAccelerationZ.restype = c_int
dll.BVTNavData_SetAccelerationZ.argtypes = (c_void_p, c_float, )
dll.BVTNavData_GetOffsetNorth.restype = c_int
dll.BVTNavData_GetOffsetNorth.argtypes = (c_void_p, POINTER(c_double), )
dll.BVTNavData_GetOffsetNorthTimestamp.restype = c_int
dll.BVTNavData_GetOffsetNorthTimestamp.argtypes = (c_void_p, POINTER(c_double), )
dll.BVTNavData_SetOffsetNorth.restype = c_int
dll.BVTNavData_SetOffsetNorth.argtypes = (c_void_p, c_double, )
dll.BVTNavData_GetOffsetEast.restype = c_int
dll.BVTNavData_GetOffsetEast.argtypes = (c_void_p, POINTER(c_double), )
dll.BVTNavData_GetOffsetEastTimestamp.restype = c_int
dll.BVTNavData_GetOffsetEastTimestamp.argtypes = (c_void_p, POINTER(c_double), )
dll.BVTNavData_SetOffsetEast.restype = c_int
dll.BVTNavData_SetOffsetEast.argtypes = (c_void_p, c_double, )
dll.BVTNavData_GetOffsetIsFromLatLongFlag.restype = c_int
dll.BVTNavData_GetOffsetIsFromLatLongFlag.argtypes = (c_void_p, POINTER(c_int), )
dll.BVTNavData_GetOffsetIsFromLatLongFlagTimestamp.restype = c_int
dll.BVTNavData_GetOffsetIsFromLatLongFlagTimestamp.argtypes = (c_void_p, POINTER(c_double), )
dll.BVTNavData_SetOffsetIsFromLatLongFlag.restype = c_int
dll.BVTNavData_SetOffsetIsFromLatLongFlag.argtypes = (c_void_p, c_int, )
dll.BVTNavData_GetUserNavString.restype = c_int
dll.BVTNavData_GetUserNavString.argtypes = (c_void_p, c_char_p, c_int, )
dll.BVTNavData_GetUserNavStringTimestamp.restype = c_int
dll.BVTNavData_GetUserNavStringTimestamp.argtypes = (c_void_p, POINTER(c_double), )
dll.BVTNavData_SetUserNavString.restype = c_int
dll.BVTNavData_SetUserNavString.argtypes = (c_void_p, c_char_p, )
dll.BVTNavData_GetSource.restype = c_int
dll.BVTNavData_GetSource.argtypes = (c_void_p, c_char_p, c_int, )
dll.BVTNavData_GetSourceLength.restype = c_int
dll.BVTNavData_GetSourceLength.argtypes = (c_void_p, POINTER(c_int), )
dll.BVTNavData_GetSourceTimestamp.restype = c_int
dll.BVTNavData_GetSourceTimestamp.argtypes = (c_void_p, POINTER(c_double), )
dll.BVTNavData_SetSource.restype = c_int
dll.BVTNavData_SetSource.argtypes = (c_void_p, c_char_p, )
dll.BVTNavData_GetUTMLongitudeZone.restype = c_int
dll.BVTNavData_GetUTMLongitudeZone.argtypes = (c_void_p, c_char_p, c_int, )
dll.BVTNavData_GetUTMLongitudeZoneTimestamp.restype = c_int
dll.BVTNavData_GetUTMLongitudeZoneTimestamp.argtypes = (c_void_p, POINTER(c_double), )
dll.BVTNavData_SetUTMLongitudeZone.restype = c_int
dll.BVTNavData_SetUTMLongitudeZone.argtypes = (c_void_p, c_char_p, )
dll.BVTNavData_GetHeaveTimestamp.restype = c_int
dll.BVTNavData_GetHeaveTimestamp.argtypes = (c_void_p, POINTER(c_double), )
dll.BVTNavData_GetHeave.restype = c_int
dll.BVTNavData_GetHeave.argtypes = (c_void_p, POINTER(c_float), )
dll.BVTNavData_SetHeave.restype = c_int
dll.BVTNavData_SetHeave.argtypes = (c_void_p, c_float, )
dll.BVTNavData_GetNavTime.restype = c_int
dll.BVTNavData_GetNavTime.argtypes = (c_void_p, POINTER(c_double), )
dll.BVTNavData_GetNavTimeTimestamp.restype = c_int
dll.BVTNavData_GetNavTimeTimestamp.argtypes = (c_void_p, POINTER(c_double), )
dll.BVTNavData_SetNavTime.restype = c_int
dll.BVTNavData_SetNavTime.argtypes = (c_void_p, c_double, )

