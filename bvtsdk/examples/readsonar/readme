	// Now, get a ping!
	BVTPing ping = NULL;
	ret = BVTHead_GetPing(head, 0, &ping);
	if( ret != 0 )
	{
		printf("BVTHead_GetPing: ret=%d\n", ret);
		return 1;
	}
	
	// Generate an image from the ping
	BVTMagImage img;
	ret = BVTPing_GetImage(ping, &img);
	if( ret != 0 )
	{
		printf("BVTPing_GetImage: ret=%d\n", ret);
		return 1;
	}

	printf("\n");

	/////////////////////////////////////////////////////////
	// Use OpenCV to display the image
	
	int height;
	BVTMagImage_GetHeight(img, &height);
	int width;
	BVTMagImage_GetWidth(img, &width);

	// Create a IplImage header
	IplImage* gray_img = cvCreateImageHeader(cvSize(width,height), IPL_DEPTH_16U, 1);
	
	// And then set it's data
	// Note: This means that the IplImage points to memory 'owned'
	// by the SDK.  Make sure that you don't use gray_img after you've
	// destroyed the img.
	unsigned short* bitBuffer;
	BVTMagImage_GetBits(img, &bitBuffer);
	cvSetImageData(gray_img,  bitBuffer, width*2);
	
	// Make a new window and show the image
	char gray_wnd[] = "Gray";
	cvNamedWindow(gray_wnd, 1);
	cvShowImage(gray_wnd, gray_img);


    BVTColorImage_Destroy(cimg);
	BVTMagImage_Destroy(img);
	BVTColorMapper_Destroy(mapper);
	BVTPing_Destroy(ping);


    int key,pkgCnt,cnt,sendNum,toSendDataNum,test;
    int i,k,sum,sendCnt = 0;;
    //struct ImgDataStr imgData;
    unsigned char *pImg,*pPkg;
    int picSize;

    time_t t;
    struct tm *lt;

    static int us;
    struct timeval tv;
    struct timezone tz;
    int us1,us2;


        resendPos++;        
        if(resendPos >= PIC_RESEND_BKP_NUM) resendPos = 0;
        //resendPicBuf[resendPos].picIndex = MAX_PIC_INDEX;
        imencode(".jpg", frame, resendPicBuf[resendPos].pic);//7～8ms

        picSize = resendPicBuf[resendPos].pic.size();
        resendPicBuf[resendPos].size = picSize;
        picIndex++;
        if(picIndex >= MAX_PIC_INDEX) picIndex = 0;
        resendPicBuf[resendPos].picIndex = picIndex;

            for(pkgCnt=0,sendNum=0;sendNum<picSize;pkgCnt++,sendNum += MAX_PACKAGE_DATA_NUM){
            if(sendNum + MAX_PACKAGE_DATA_NUM < picSize){
                toSendDataNum = MAX_PACKAGE_DATA_NUM;
            }
            else toSendDataNum = picSize - sendNum;

            //#define  PKG_RANDOM_ORDER_TEST  //乱序发包，测试数据包排序功能
            #ifdef PKG_RANDOM_ORDER_TEST
                        if(pkgCnt == 0) test = 1;
                        else if(pkgCnt == 1) test = 0;
                        else test = pkgCnt;
            #else
                        test = pkgCnt;
            #endif

            pthread_mutex_lock(sendMutex);//UDP发送 互斥
            pImg = resendPicBuf[resendPos].pic.data()+MAX_PACKAGE_DATA_NUM*test;
            pPkg = &pkgData[PACKAGE_HEAD_LENGTH];
            memcpy(pPkg,pImg,toSendDataNum);

            setPkgHead(resendPicBuf[resendPos].picIndex, test, resendPicBuf[resendPos].size);
            pkgHead = getPkgHead(pkgData);
            //cout<<"pkgCnt"<<(int)pkgHead.pkgIndex<<"send:" << pkgHead.size<<endl;

            time (&t);//获取Unix时间戳。
            lt = localtime (&t);//转为时间结构。
            //printf ( "1:%d/%d/%d %d:%d:%d\n",lt->tm_year+1900, lt->tm_mon, lt->tm_mday, lt->tm_hour, lt->tm_min, lt->tm_sec);//输出结果

            clock_t ct1 = clock();

            //30～110us
            cnt = sendto(sockfd, (const void*)&pkgData, \
                  toSendDataNum+PACKAGE_HEAD_LENGTH, 0, (struct sockaddr*)&addr,addrLen);

            pthread_mutex_unlock(sendMutex);

            //为数据包发送预留时间，减少快速发送大量数据造成网络拥堵
            //可以逐步增大时间到不出现或很少 error frame 为止
            if(sendCnt%5 == 4)
                usleep(2000);

            clock_t ct2 = clock();
            //printf("ct2:%d\n",ct2-ct1);

            time (&t);//获取Unix时间戳。
            lt = localtime (&t);//转为时间结构。
            //printf ( "2:%d/%d/%d %d:%d:%d\n",lt->tm_year+1900, lt->tm_mon, lt->tm_mday, lt->tm_hour, lt->tm_min, lt->tm_sec);//输出结果

            if (cnt < 0){
                cerr<<TAG<<"ERROR writing to udp socket:"<<cnt;
                return;
            }
        }